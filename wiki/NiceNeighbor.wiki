#summary How Cajita coexists with untranslated JavaScript

See SubsetRelationships for context.

= Coexistence Today by Taming =

----
http://google-caja.googlecode.com/svn/trunk/doc/images/nn-today.png
----

On !JavaScript as implemented on browsers today (ES3R), inter-object security is not quite defensible against untrusted, untranslated, unverified !JavaScript code. Thus, Cajita's security today relies on the assumption that Cajita objects will only be made directly accessible to 
 # _Cajoled code_, i.e., the !JavaScript code generated by a cajoler -- a trusted Cajita-to-!JavaScript compiler.
 # _Trusted !JavaScript_, such as cajita.js -- the Cajita runtime.
 # _Tamed innocent !JavaScript_, such as the core ES3 library or the browser's DOM API.

The first two are the subject of TranslationTarget. The third, _tamed
innocent !JavaScript_, is the subject of this page. This page explains
the taming API provided by the Cajita runtime and how to use it to
tame innocent !JavaScript. Taming is the design of the interface
between cajoled and uncajoled !JavaScript. The taming is based on
whitelisting -- unless an uncajoled property is explicitly made
visible by taming, it is not visible to Cajita code. For those
properties that are made visible, taming can attenuate what
interactions are possible across the boundary.

_Innocent code_ is code written without awareness of the possibility
of evil. Innocent code neither seeks to do evil, nor does it engage in
any defensive practices needed to resist evil. Although most existing
!JavaScript code is innocent, without strong evidence to the contrary,
we must classify most code as untrusted, i.e., potentially hostile. If
we misclassify hostile code as innocent, Cajita's security is lost. We
assume innocent code may be buggy, but that none of these bugs can be
exploited by an attacker, via the available attack surface, to cause
the innocent code to act as hostile code. Again, if we misclassify
exploitable code as innocent, Cajita's security is lost.

Some innocent code is directly provided by the target platform -- such
as the code ES3 libraries and the browser's DOM API. This code is not
subject to examination or translation. For all other innocent code, we
do assume that it has been translated through our
InnocentCodeRewriter. _*Note: As of this writing, all deployments of
Caja violate this assumption. Once we fix issue 1019, we must repair
this unsafe situation.*-

== Security Properties to be maintained by taming ==

Even with the above problem repaired, and even assuming no malicious
or exploitable code is misclassified as innocent,
[http://combex.com/papers/darpa-review/ previous] [http://google-caja.googlecode.com/files/Caja_External_Security_Review_v2.pdf experiences] 
suggest that taming is the most hazardous part of
securing a legacy platform, and bad taming decisions are the most
likely source of fatal security problems. The taming of innocent
!JavaScript must carefully ensure that the security properties
enforced by a cajoler together with the Cajita runtime are not
violated by innocent !JavaScript. These security properties are:

=== Closure encapsulation === 

!JavaScript today has only one almost working security mechanism --
lexical variable capture by nested functions. Although the ES3
specification provides no operations for violating this encapsulation,
neither does it prohibit the addition of such operations by conforming
platforms. ES3R (ES3 as implemented on today's browsers) universally
provides operations -- `arguments.caller`, _function_`.caller`, and
_function_`.arguments` -- which allow uncajoled code to violate the
encapsulation of functions on their call stack. Taming should only
allow cajoled code to call uncajoled code when none of the uncajoled
code reachable from those entry points might employ one of these
operations to violate the encapsulation of a Cajita closure on its
call chain.

=== Simulated Attributes Restrict Property Manipulation ===

In the language of the ES3 spec, each property has associated with it
a set of attributes. (To avoid confusion, we will use the ES5 names
for these attributes, even when speaking about ES3.) For example, if
the `[[Writable]]` attribute of a property is false, the property is
read-only and cannot be changed by assignment. However, neither ES3
nor ES3R provide any way for !JavaScript code to create properties
with non-default attribute settings. But Cajita requires such
restrictions in order to create tamper-proof objects.

Cajita on the ES3R platform simulates attribute-based restrictions of
property manipulation by representing such per-property virtual
attribute settings in its own bookkeeping. Cajoling translates Cajita
code into cajoled !JavaScript code that cannot violate the
restrictions represented in this bookkeeping. However, innocent
!JavaScript knows nothing of the restrictions represented in this
bookkeeping, and may therefore innocently violate these restrictions.

For example, say malicious Cajita object Mallet has access to both
frozen victim Cajita object Fred and to innocent mutating object
Inara. Since Mallet is written in Cajita, it is translated into code
which _cannot_ directly mutate Fred. However, if Inara were
innappropriately tamed, such that Mallet could pass Fred as an
argument to one of Inara's mutating operations, then Mallet could get
Inara to innocently do the forbidden mutation on his behalf.

=== No Access to Global object or scope ===


=== No Exophoric Functions ===


For purposes of taming, we first classify !JavaScript values into one
of the following categories:
  # Primitive values. These are unconditionally accessible from both Cajita and !JavaScript.
     # numbers, strings, booleans.
     # null and undefined. Note that `typeof null === "object"`.
  # Objects that Cajita code cannot create, but that can be made available to Cajita by taming.
     # Constructors. A tamed constructor is a function mentioning `this`, typically meant to be invoked with `new`, whose `prototype` property points at a _prototypical object_ (defined below) whose `constructor` property points back at this constructor. Constructors are for expressing class-like inheritance, and so can also be invoked by a constructor representing a "subclass" in order to initialize their "superclass" portion of the object. Cajita code can only invoke constructors with `new`, which is fine since Cajita code cannot define "subclass" constructors anyway. To Cajita code, constructors are always frozen.
     # Constructed objects. An object is a constructed object if it is not a function and the first prototypical object on its prototype chain is not `Object.prototype` or `Array.prototype`. The value of that prototypical object's `constructor` property is the _direct constructor_ of the constructed object. A constructed object should only be accessible to Cajita code if its direct constructor has been tamed as a constructor. Cajita code can only see whitelisted properties of constructed objects, and cannot extend constructed objects with new properties.
     The allowed constructors and constructed objects necessarily includes the primitive value wrappers: Numbers, Strings, and Booleans. Good code should never create wrappers, but defensive code must be prepared to receive wrappers as arguments.
  # Objects that Cajita code can create. These can also be made available by taming.
     # Simple-functions. A function not mentioning `this`. Such a function can be safely invoked as a function, as a constructor using `new`, or as a method. Cajita code implicitly postpones freezing a named simple-function until its first use or escaping occurrence, so that it can initialize static properties on it. Anonymous simple-functions are born frozen. Tamed simple-functions, whether named or not, are also immediately frozen on taming. Any static property on a tamed simple function to be made available must by tamed as non-writable.
     # Records.
     # Arrays.
  # !JavaScript values that must not be made available to Cajita code.
     # The global object.
     # Exophoric functions.
     # Prototypical objects.
     # Functions not enumerated by a taming decision and their instances.
     # Host objects. Because even the specified semantics of host objects is an unpredictable mess, we currently prevent Cajita code from ever obtaining access to a host object. However, for taming the browser DOM tree (without weak pointers or weak tables), this technique prevents the garbage collector from doing its job. We may relax this restriction until !JavaScript provides weak tables.
     # Genuine `arguments` objects. The object created by the !JavaScript expression `arguments` has bizarre semantics. It may or may not inherits from `Array.prototype`, it acts in some array-like ways but is not an array, it is typically joined to the parameter variables of the function that created it, and there is no test that can reliably determine whether a given object is an `arguments` object.
  # !JavaScript values that must never be encountered by the Cajita runtime.
     # Ill-formed prototype chains. Note that taming is too late to prevent this. Safest would be not to allow such cases onto the page. (TODO rephrase without "page" concept.)

== Taming Normal Property Attributes ==



|| *Current API* || *Similar ES5 attribute* || *Common Semantics*|| *Differences* ||
|| `___.grantRead(`_obj_`,`_name_`)` || _none_ || ES5 has no non-readable properties. In Cajita taming of JSON containers, all actual properties are implicitly visible to cajoled code. In either case this call is unnecessary and redundant. || In Cajita taming of constructed objects, this makes actual uncajoled properties visible to cajoled code. ||
|| `___.setPub(`_obj_`,`_name_`,`_val_`)` || `{value:`_val_`, writable:true, enumerable:true}` || If the property's value is mutable, sets its value. || In a non-frozen Cajita JSON container, all properties are mutable. In ES5, if a property is configurable but not writable, then it can be mutated by the meta API but not by assignment. ||
|| `___.grantSet(`_obj_`,`_name_`)` || `{writable:true, enumerable:true}` || Allow the actual property to be changed by assignment. || In ES5, this really says whether the property value may change. In Cajita taming, it says whether Cajita code can assign to it. ||
|| `___.grantEnum(`_obj_`,`_name_`)` || `{enumerable:true}` || This property _name_ will be enumerated by a for-in loop on _obj_. || ||
|| `___.grantDelete(`_obj_`,`_name_`)` || `{configurable:true}` || The property can be deleted. || In ES5, if a property is configurable, its attributes may change at runtime. In Cajita taming, uncajoled code can change attributes unconditionally but does typically only on initialization; cajoled code can only freeze or, for deletable properties, delete it. All properties on non-frozen JSON containers are implicitly deletable. ||

== Installing Property Accessors ==

|| *Current API* || *Similar ES5 attribute* || *Common Semantics*|| *Differences* ||
|| `___.useGetHandler(`_obj_`,`_name_`,`_getter_`}` || `{get:`_getter_`}` || Reading the property obtains the result of calling _getter_`.call(`_obj_`)` || Cajita handlers are only tried after normal data lookup fails. ||
|| `___.useSetHandler(`_obj_`,`_name_`,`_setter_`}` || `{set:`_setter_`}` || Assigning _val_ to the property calls _setter_`.call(`_obj_`,`_val_`)`. The value of the assignment expression is _val_, not the result of the setter call. || Cajita handlers are only tried after normal data lookup fails. ES5 represents a non-writable accessor property by `{set:undefined}`. Cajita has no equivalent. ||

== Taming Functions ==

|| *Current API* || *Meaning* ||
|| `___.ctor(`_fun_`,`_optname_`)` || Marks _fun_ as a constructor -- it can only be called with `new`. ||
|| `___.frozenFunc(`_fun_`,`_optname_`)` || Marks _fun_ as a simple-function -- one that does not mention `this`. A simple function can be called as a function, method, or constructor. It is first class -- reading a readable property whose value is a simple-function obtains the simple-function itself. ||
|| `___.func(`_fun_`,`_optname_`)` || Not a taming API. Should only be called by the cajoler's generated code. ||

== Taming Methods ==

|| *Current API* || *Meaning* ||
|| `___.grantFunc(`_obj_`,`_name_`)` || Use when _obj_`[`_name_`]` is a safe simple-function, i.e., a function that does not mention `this` that should be invokable from Cajita. ||
|| `___.grantGeneric(`_obj_`,`_name_`)` || ||
|| `___.grantTypedGeneric(`_obj_`,`_name_`)` || ||
|| `___.grantMutator(`_obj_`,`_name_`)` || ||
|| `___.handleGeneric(`_obj_`,`_name_`,`_callHandler_`)` || ||


= Future defensibility from untranslated code =

----
http://google-caja.googlecode.com/svn/trunk/doc/images/nn-future.png
----

== Does ES5 protect Cajita from untrusted !JavaScript? ==

Let's reexamine each of the security properties Cajita relies on.

=== Closure encapsulation === 

Mostly, yes. 

Cajita functions will translate to ES5-strict functions. The three
closure-breaking operations of ES3R -- `arguments.caller`,
_function_`.caller`, and _function_`.arguments` -- are not available
on strict functions, even from nonstrict functions. In designing the
new _meta_ API for ES5 (the reflective property manipulation methods
on `Object`, covered next), we were careful not to introduce any new
ways to violate closure encapsulation.

The only reason for the _mostly_ qualifier above is that the ES5 spec,
like the ES3 spec before it, contains a grand loophole (chapter 16)
that allows an implementation to provide virtually any extension and
still claim conformance to the spec.

=== Simulated Attributes Restrict Property Manipulation ===

Yes. But with a new restriction on innocent code.

To be explained.

=== No Access to Global object or scope ===

Between frames, yes. Within a frame, we still prevent priviledge escalation.

To be explained.


=== No Exophoric Functions ===

No. This inability forces us to change our strategy.

To be explained.