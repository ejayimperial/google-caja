#summary How Cajita coexists with untranslated JavaScript

See SubsetRelationships for context.

= Coexistence Today by Taming =

----
http://google-caja.googlecode.com/svn/trunk/doc/images/nn-today.png
----

On !JavaScript as implemented on browsers today (ES3R), inter-object security is not quite defensible against untrusted, untranslated, unverified !JavaScript code. Thus, Cajita's security today relies on the assumption that Cajita objects will only be made directly accessible to 
 # _Cajoled code_, i.e., the !JavaScript code generated by a cajoler -- a trusted Cajita-to-!JavaScript compiler.
 # _Trusted !JavaScript_, such as cajita.js -- the Cajita runtime.
 # _Tamed innocent !JavaScript_, such as the core ES3 library or the browser's DOM API.

The first two are the subject of TranslationTarget. The third, _tamed innocent !JavaScript_, is the subject of this page. This page explains the taming API provided by the Cajita runtime and how to use it to tame innocent !JavaScript. The taming of innocent !JavaScript must carefully ensure that the security properties enforced by a cajoler together with the Cajita runtime are not violated by innocent !JavaScript.

_Innocent code_ is code written without awareness of the possibility of evil. Innocent code neither seeks to do evil, nor does it engage in any defensive practices needed to resist evil. Although most existing !JavaScript code is innocent, without strong evidence to the contrary, we must classify most code as untrusted, i.e., potentially hostile. If we misclassify hostile code as innocent, Cajita's security is lost. We assume innocent code may be buggy, but that none of these bugs can be exploited by an attacker via the available attack surface to cause the innocent code to act as hostile code. Again, if we misclassify exploitable code as innocent, Cajita's security is lost. 

Some innocent code is directly provided by the target platform -- such as the code ES3 libraries and the browser's DOM API. This code is not subject to examination or translation. For all other innocent code, we do assume that it has been translated through our InnocentCodeRewriter. _*Note: As of this writing, all deployments of Caja violate this assumption. Once we fix issue XXX, we must repair this unsafe situation.*-

== Taming Normal Property Attributes ==

|| *Current API* || *Similar ES5 attribute* || *Common Semantics*|| *Differences* ||
|| `___.grantRead(`_obj_`,`_name_`)` || _none_ || ES5 has no non-readable properties. In Cajita taming of JSON containers, all actual properties are implicitly visible to cajoled code. In either case this call is unnecessary and redundant. || In Cajita taming of constructed objects, this makes actual uncajoled properties visible to cajoled code. ||
|| `___.setPub(`_obj_`,`_name_`,`_val_`)` || `{value:`_val_`, writable:true, enumerable:true}` || If the property's value is mutable, sets its value. || In a non-frozen Cajita JSON container, all properties are mutable. In ES5, if a property is configurable but not writable, then it can be mutated by the meta API but not by assignment. ||
|| `___.grantSet(`_obj_`,`_name_`)` || `{writable:true, enumerable:true}` || Allow the actual property to be changed by assignment. || In ES5, this really says whether the property value may change. In Cajita taming, it says whether Cajita code can assign to it. ||
|| `___.grantEnum(`_obj_`,`_name_`)` || `{enumerable:true}` || This property _name_ will be enumerated by a for-in loop on _obj_. || ||
|| `___.grantDelete(`_obj_`,`_name_`)` || `{configurable:true}` || The property can be deleted. || In ES5, if a property is configurable, its attributes may change at runtime. In Cajita taming, uncajoled code can change attributes unconditionally but does typically only on initialization; cajoled code can only freeze or, for deletable properties, delete it. All properties on non-frozen JSON containers are implicitly deletable. ||

== Installing Property Accessors ==

|| *Current API* || *Similar ES5 attribute* || *Common Semantics*|| *Differences* ||
|| `___.useGetHandler(`_obj_`,`_name_`,`_getter_`}` || `{get:`_getter_`}` || Reading the property obtains the result of calling _getter_`.call(`_obj_`)` || Cajita handlers are only tried after normal data lookup fails. ||
|| `___.useSetHandler(`_obj_`,`_name_`,`_setter_`}` || `{set:`_setter_`}` || Assigning _val_ to the property calls _setter_`.call(`_obj_`,`_val_`)`. The value of the assignment expression is _val_, not the result of the setter call. || Cajita handlers are only tried after normal data lookup fails. ES5 represents a non-writable accessor property by `{set:undefined}`. Cajita has no equivalent. ||

== Taming Functions ==

|| *Current API* || *Meaning* ||
|| `___.ctor(`_fun_`,`_optname_`)` || Marks _fun_ as a constructor -- it can only be called with `new`. ||
|| `___.frozenFunc(`_fun_`,`_optname_`)` || Marks _fun_ as a simple-function -- one that does not mention `this`. A simple function can be called as a function, method, or constructor. It is first class -- reading a readable property whose value is a simple-function obtains the simple-function itself. ||
|| `___.func(`_fun_`,`_optname_`)` || Not a taming API. Should only be called by the cajoler's generated code. ||

== Taming Methods ==

|| *Current API* || *Meaning* ||
|| `___.grantFunc(`_obj_`,`_name_`)` || Use when _obj_`[`_name_`]` is a safe simple-function, i.e., a function that does not mention `this` that should be invokable from Cajita. ||
|| `___.grantGeneric(`_obj_`,`_name_`)` || ||
|| `___.grantTypedGeneric(`_obj_`,`_name_`)` || ||
|| `___.grantMutator(`_obj_`,`_name_`)` || ||
|| `___.handleGeneric(`_obj_`,`_name_`,`_callHandler_`)` || ||


= Future defensibility from untranslated code =

----
http://google-caja.googlecode.com/svn/trunk/doc/images/nn-future.png
----