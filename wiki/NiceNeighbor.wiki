#summary How Cajita coexists with untranslated JavaScript

See SubsetRelationships for context.

= Coexistence Today by Taming =

----
http://google-caja.googlecode.com/svn/trunk/doc/images/nn-today.png
----

On !JavaScript as implemented on browsers today (ES3R), inter-object security is not quite defensible against untrusted, untranslated, unverified !JavaScript code. Thus, Cajita's security today relies on the assumption that Cajita objects will only be made directly accessible to 
 # _Cajoled code_, i.e., the !JavaScript code generated by a cajoler -- a trusted Cajita-to-!JavaScript compiler.
 # _Trusted !JavaScript_, such as cajita.js -- the Cajita runtime.
 # _Tamed innocent !JavaScript_, such as the core ES3 library or the browser's DOM API.

The first two are the subject of TranslationTarget. The third, _tamed
innocent !JavaScript_, is the subject of this page. This page explains
the taming API provided by the Cajita runtime and how to use it to
tame innocent !JavaScript. Taming is the design of the interface
between cajoled and uncajoled !JavaScript. The taming is based on
whitelisting -- unless an uncajoled property is explicitly made
visible by taming, it is not visible to Cajita code. For those
properties that are made visible, taming can attenuate what
interactions are possible across the boundary.

_Innocent code_ is code written without awareness of the possibility
of evil. Innocent code neither seeks to do evil, nor does it engage in
any defensive practices needed to resist evil. Although most existing
!JavaScript code is innocent, without strong evidence to the contrary,
we must classify most code as untrusted, i.e., potentially hostile. If
we misclassify hostile code as innocent, Cajita's security is lost. We
assume innocent code may be buggy, but that none of these bugs can be
exploited by an attacker, via the available attack surface, to cause
the innocent code to act as hostile code. Again, if we misclassify
exploitable code as innocent, Cajita's security is lost.

Some innocent code is directly provided by the target platform -- such
as the code ES3 libraries and the browser's DOM API. This code is not
subject to examination or translation. For all other innocent code, we
do assume that it has been translated through our
InnocentCodeRewriter. _*Note: As of this writing, all deployments of
Caja violate this assumption. Once we fix issue 1019, we must repair
this unsafe situation.*-

== Security Properties to be maintained by taming ==

Even with the above problem repaired, and even assuming no malicious
or exploitable code is misclassified as innocent,
[http://combex.com/papers/darpa-review/ previous] [http://google-caja.googlecode.com/files/Caja_External_Security_Review_v2.pdf experiences] 
suggest that taming is the most hazardous part of
securing a legacy platform, and bad taming decisions are the most
likely source of fatal security problems. The taming of innocent
!JavaScript must carefully ensure that the security properties
enforced by a cajoler together with the Cajita runtime are not
violated by innocent !JavaScript. These security properties are:

=== Closure encapsulation === 

!JavaScript today has only one almost working security mechanism --
lexical variable capture by nested functions. Although the ES3
specification provides no operations for violating this encapsulation,
neither does it prohibit the addition of such operations by conforming
platforms. ES3R (ES3 as implemented on today's browsers) universally
provides operations -- `arguments.caller`, _function_`.caller`, and
_function_`.arguments` -- which allow uncajoled code to violate the
encapsulation of functions on their call stack. Taming should only
allow cajoled code to call uncajoled code when none of the uncajoled
code reachable from those entry points might employ one of these
operations to violate the encapsulation of a Cajita closure on its
call chain.

=== Simulated Attributes Restrict Property Manipulation ===


=== No Access to Global object or scope ===


=== No Exophoric Functions ===


== Taming Normal Property Attributes ==

|| *Current API* || *Similar ES5 attribute* || *Common Semantics*|| *Differences* ||
|| `___.grantRead(`_obj_`,`_name_`)` || _none_ || ES5 has no non-readable properties. In Cajita taming of JSON containers, all actual properties are implicitly visible to cajoled code. In either case this call is unnecessary and redundant. || In Cajita taming of constructed objects, this makes actual uncajoled properties visible to cajoled code. ||
|| `___.setPub(`_obj_`,`_name_`,`_val_`)` || `{value:`_val_`, writable:true, enumerable:true}` || If the property's value is mutable, sets its value. || In a non-frozen Cajita JSON container, all properties are mutable. In ES5, if a property is configurable but not writable, then it can be mutated by the meta API but not by assignment. ||
|| `___.grantSet(`_obj_`,`_name_`)` || `{writable:true, enumerable:true}` || Allow the actual property to be changed by assignment. || In ES5, this really says whether the property value may change. In Cajita taming, it says whether Cajita code can assign to it. ||
|| `___.grantEnum(`_obj_`,`_name_`)` || `{enumerable:true}` || This property _name_ will be enumerated by a for-in loop on _obj_. || ||
|| `___.grantDelete(`_obj_`,`_name_`)` || `{configurable:true}` || The property can be deleted. || In ES5, if a property is configurable, its attributes may change at runtime. In Cajita taming, uncajoled code can change attributes unconditionally but does typically only on initialization; cajoled code can only freeze or, for deletable properties, delete it. All properties on non-frozen JSON containers are implicitly deletable. ||

== Installing Property Accessors ==

|| *Current API* || *Similar ES5 attribute* || *Common Semantics*|| *Differences* ||
|| `___.useGetHandler(`_obj_`,`_name_`,`_getter_`}` || `{get:`_getter_`}` || Reading the property obtains the result of calling _getter_`.call(`_obj_`)` || Cajita handlers are only tried after normal data lookup fails. ||
|| `___.useSetHandler(`_obj_`,`_name_`,`_setter_`}` || `{set:`_setter_`}` || Assigning _val_ to the property calls _setter_`.call(`_obj_`,`_val_`)`. The value of the assignment expression is _val_, not the result of the setter call. || Cajita handlers are only tried after normal data lookup fails. ES5 represents a non-writable accessor property by `{set:undefined}`. Cajita has no equivalent. ||

== Taming Functions ==

|| *Current API* || *Meaning* ||
|| `___.ctor(`_fun_`,`_optname_`)` || Marks _fun_ as a constructor -- it can only be called with `new`. ||
|| `___.frozenFunc(`_fun_`,`_optname_`)` || Marks _fun_ as a simple-function -- one that does not mention `this`. A simple function can be called as a function, method, or constructor. It is first class -- reading a readable property whose value is a simple-function obtains the simple-function itself. ||
|| `___.func(`_fun_`,`_optname_`)` || Not a taming API. Should only be called by the cajoler's generated code. ||

== Taming Methods ==

|| *Current API* || *Meaning* ||
|| `___.grantFunc(`_obj_`,`_name_`)` || Use when _obj_`[`_name_`]` is a safe simple-function, i.e., a function that does not mention `this` that should be invokable from Cajita. ||
|| `___.grantGeneric(`_obj_`,`_name_`)` || ||
|| `___.grantTypedGeneric(`_obj_`,`_name_`)` || ||
|| `___.grantMutator(`_obj_`,`_name_`)` || ||
|| `___.handleGeneric(`_obj_`,`_name_`,`_callHandler_`)` || ||


= Future defensibility from untranslated code =

----
http://google-caja.googlecode.com/svn/trunk/doc/images/nn-future.png
----