#summary Documents differences between SES (Secure EcmaScript) and ES5 (EcmaScript 5).

_All mentions of "ES5" below actually refer to !EcmaScript 5.1_

<wiki:toc max_depth="8" />

= Introduction =

SES is mostly defined as a fail-stop subset of ES5 that should compatibly run all ES5 code that follows recognized ES5 best practices. The SES restrictions support the writing of defensively consistent abstractions -- object abstractions that can defend their integrity while being exposed to untrusted but confined objects.

This page is for hard core developers, to document precisely the differences between the various forms of SES, and how these differ from ES5. Introductory and tutorial material will appear elsewhere. _*where?*_

= ES6 extras: `WeakMaps` =

There is one crucial way in which SES is more than a subset of ES5 though still a subset of ES6 -- the inclusion of the [http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps WeakMap abstraction] proposed for !EcmaScript 6. Over time, as more of ES6 settles down and becomes available in !JavaScript implementations, we expect to make more of these features available within SES as well. Note that `WeakMap` is always available in SES, whether or not it is available yet on the underlying !JavaScript platform. (When it does not derive from platform provided `WeakMap`s, the [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/WeakMap.js emulated WeakMaps] are necessarily leaky, but this is technically a quality of implementation issue rather than a correctness issue.)

= Idealized SES vs ES5 vs ES5 best practices =

== Strict and Non-Strict Code ==

By default, ES5 code is non-strict, which is compatible enough with legacy ES3 code in exhange for preserving most of the semantic minefields that make ES3 programming hell. For example, ES5 non-strict code, like ES3 code, is not lexically scoped, and in ways almost no one understood. Non-strict failed assignments are silent, allowing control flow to proceed on paths that assumed success.

So ES5 best practice is to always [http://wiki.ecmascript.org/doku.php?id=conventions:avoid_strictness_contagion opt-in to strict mode].

SES enforces that all SES code is strict, i.e., as if it had opted into strict mode, whether it does so explicitly or not. For ES5 code that follows ES5 best practices, this enforcement of strict code makes no difference.

== Whitelisted Primordial Properties ==

The notorious [http://es5.github.com/#x16 Chapter 16 exemptions] of the ES5 spec says that

  An implementation may provide additional types, values, objects, *_properties_*, and functions 
  beyond those described in this specification. This may cause constructs (such as looking up 
  a variable in the global scope) to have implementation-defined behaviour instead of throwing 
  an error (such as !ReferenceError).
_emphasis added_

Implementations do indeed make use of this freedom and provide all sorts of non-standard properties, many of which are semantically problematic (e.g., `RegExp.prototype.compile`, `RegExp.leftContext`), and that often differ from browser to browser (e.g., `__proto__`). Nevertheless, some properties that are not _de jure_ standards are unproblematic and universal, and have come to be recognized as harmless _de facto_ standards (e.g., `String.prototype.anchor`).

ES5 best practice limits code to relying only on such _de jure_ or harmless _de facto_ properties. While best practice code may attempt to use non-standard features when present, all such uses should be conditioned on feature tests for the presence of these properties, and the code should continue to work correctly in their absence.

SES is partially specified by its [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/whitelist.js whitelist], which includes all ES5 standard properties and those _de facto_ properties that we judge to be safe. SES guarantees the absence of any primordial properties that are absent from its whitelist. For ES5 code that follows ES5 best practices, these absences are unproblematic.

== Whitelisted Global Variables ==

Likewise, ES5 allows the global object to contain arbitrary properties, thereby defining arbitrary new global variables of the same names. The [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/whitelist.js SES whitelist] also defines what global variables are visible to SES code. The whitelisted globals include all the ES5 standard globals, the harmless _de facto_ standard *[http://es5.github.com/#B.2.1 escape]* and *[http://es5.github.com/#B.2.2 unescape]*, *`WeakMap`* as mentioned above, *[http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/StringMap.js StringMap]*, which is a special case of the [http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets proposed ES6 Map], and (for now) the global *`cajaVM`*, which provides a collection of other SES and Caja specific additional APIs. Notably absent from SES itself are authority providing globals such as `document`, `window`, or `location`.

We do not intend to propose `cajaVM` itself be part of the future _de jure_ Ecma SES standard. Any functionality on `cajaVM` we wish to standardize, we will relocate and possibly refactor before proposing as a _de jure_ standard.

To write _platform independent_ !JavaScript code, i.e., code that is independent of whether its hosting environment is a browser, server, or whatever, ES5 best practice is to not rely on any non-standard globals. As with non-standard properties, best practice code may attempt to use such non-standard globals if present, but should condition such usage on feature testing whether those variables are present and have a value other than `undefined`, such as by testing
{{{
    if (typeof someConventionalGlobal === 'undefined') {
      // If someConventionalGlobal is either absent or has value undefined
      // Fallback behavior may simply be to terminate with an informative diagnostic
    } else {
      // If someConventionalGlobal is both present and has a non-undefined value
      // we may use it, assuming it has its conventional meaning
    }
}}}

Beyond the whitelisted globals, SES code may see additional global variable names depending on how it is spawned, including names like `document`, etc, which are bound to values emulating the traditional browser environment. _*We need to explain these spawning and scoping options somewhere*_

For ES5 best practice code that assumes (without testing) a hosting environment with additional globals, the SES code setting up the spawning environment can endow it with an emulation of the additional globals assumed by code expecting to run in that environment. Caja's [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/plugin/domado.js Domado library] provides just such a safe emulation of the browser environment.

== Only Standard Syntax ==

The notorious [http://es5.github.com/#x16 Chapter 16 exemptions] of the ES5 spec also says that

  An implementation may extend program syntax and regular expression pattern or flag 
  syntax. To permit this, all operations (such as calling eval, using a regular expression 
  literal, or using the Function or !RegExp constructor) that are allowed to throw !SyntaxError 
  are permitted to exhibit implementation-defined behaviour instead of throwing 
  !SyntaxError when they encounter an implementation-defined extension to the program 
  syntax or regular expression pattern or flag syntax.

When this additional syntax adds only sugar whose meaning is equivalent to code that could have been written in the standard language, it presents no great problem. However, this exemption allows non-standard syntax that could express non-standard semantics, including semantics that is [https://bugzilla.mozilla.org/show_bug.cgi?id=695579 impossible to secure]. Whereas programs can feature test for additional non-standard properties, as above, it is much more difficult (though possible using `eval`) to feature test for non-standard syntax.

ES5 best practice is to write code that uses only standard syntaxes.

SES accepts only standard syntax, or at most those non-syntactic elements of the underlying platform that are morally equivalent to sugar. For ES5 code that follows ES5 best practices, this restriction makes no difference. 

Note that the parser-free _Target-SES_ implementation explained below cannot prohibit non-standard syntaxes, but rather simply refuse to run if it detects the acceptance of specific non-standard syntaxes that it knows to worry about, [https://bugzilla.mozilla.org/show_bug.cgi?id=695577 such as E4X].

== No Monkey Patching Primordials ==

In ES5, almost all specified properties of build in primordial objects are specified to start in the writable and configurable state. And the built in primordial objects are themselves specified to start in the extensible state. Since all code loaded into a context (frame) implicitly shares much of this primordial state, this implicit access to shared mutable state represents an un-granted communications channel. Worse, it allows any code in that context to engage in _prototype poisoning_, replacing inherited utility methods, like Function.prototype.call, whose meaning other code relies on for its integrity.

SES, to enforce object-capability rules, must prevent all un-granted communications channels. So in SES, all built-in primordial objects are transitively frozen, which would ideally make them immutable. However, there are three remaining sources of primordial mutability left, which we enumerate below.

Some old libraries, like _Prototype_, made use of this pervasive mutability to install its own extension, e.g., to `Array.prototype`. However, these extensions would often conflict with each other, especially if two versions of the same monkey patching library were loaded into the same context. So ES3 and ES5 best practice is to avoid mutating (or monkey patching) any built-in primordial objects. So in this regard, ES5 best practice is consistent with frozen primordial state.

Unfortunately, due to a [http://wiki.ecmascript.org/doku.php?id=strawman:fixing_override_mistake mistake made when specifying ES5], there is one bit of ES5 best practice which would break given naively frozen primordials. Suffice it to say that we specify SES to not suffer from [http://wiki.ecmascript.org/doku.php?id=strawman:fixing_override_mistake mistake made when specifying ES5], and so not be in conflict with ES5 best practices. And on conforming ES5 platforms, we implement a reasonable approximation of this spec to have only a minor impact on code following ES5 best practices. We return to this topic at [http://code.google.com/p/google-caja/wiki/SES#Tamper_Proofing_vs_Freezing Tamper Proofing vs Freezing] below. 

===Current date and time===

A no-argument call to the `Date` constructor, {{{new Date()}}}, as well as a call to {{{Date.now()}}} gives access access to the current date and time, which is an un-granted read-only access to be effected by state change of the outside world (the advance of time). Further, but providing undeniable access to time, we widen the information leakage possible through covert timing channels. Since SES makes no claims to prevent or even inhibit covert channels, and since this channel is really read-only, SES leaves it undisturbed, which is technically in violation of object-capability rules.
 
=== `Math.random()`===

`Math.random()` is a standard primordial method that provides a new random-enough number (between 0.0 and 1.0) each time it is called. This is clearly not immutable, in that each call is clearly mutating some hidden state. Were it cryptographically pseudo-random, then to any computation that does not know the hidden state, the behavior of `Math.random()` would not be observably different (for feasible observations) from a source of true random numbers, e.g., from tapping a source of physical entropy. Such a source of physical entropy need not be affected in any way by a call to Math.random(), and so we could safely consider it a read-only channel, like Date.

However, `Math.random()` is not specified to provide such high quality entropy, and actually implementations are know to provide low enough entropy to lead to actual security problems. But again, since SES makes no claims to prevent or inhibit covert channels, SES currently does not tighten this spec, and current SES implementations do not replace `Math.random()` with a higher quality source.

===Accidentally Unfreezable Mutable  State===

Even though `Date.prototype instanceof Date` returns `false`, nevertheless, `Date.prototype` is itself specified to be a Date object. (In spec language, its `[[Class]]` is `"Date"`.) Doing `Object.freeze(Date.prototype)` as well as freezing all the methods found there does not suppress all implicitly shared mutable state. Date objects have an internal property, not freezable with `Object.freeze`, that can be accessed only by the built-in Date setting methods found on `Date.prototype`.

We specify SES so that using any of the Date setting method on a Date prototype from any context (frame) causes no mutation and instead throws a !TypeError. On conforming ES5 platforms, the SES implementation realizes this spec by monkey patching the Date setting methods. On IE10, the Date setting methods indeed cause no mutation, but instead of throwing a !TypeError, they fail silently. Since the IE10 behavior is SES-safe, we currently do not monkey patch these to throw a !TypeError on IE, but may change out mind.


== No Mutable Globals ==



== Script Code vs Eval Code ==

== Direct and Indirect `eval`, and the `Function` Constructor ==

== Powerless thrown Errors, etc. ==

= SES-on-ES5 vs Idealized SES =

== Tamper Proofing vs Freezing ==

The following code does not violate any ES5 best practice:

{{{
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  Point.prototype.toString = function() {
    return '<' + x + ',' + y + '>';
  };
}}}

However, if SES simply freezes the ES5 primordials, then the above code would fail. The reason being that ES5 specifies that an attempt to override a non-writable data property with assignment fails, and we were assuming that `Point.prototype.toString` was made simply non-writable non-configurable, by freezing `Point.prototype`.

TODO

= SES vs CES (Confined !EcmaScript) =

== Waive Monkey Patching Prohibition ==

== Multi-Frame Operation ==

== Defensiveness Despite Monkey Patching ==

= Source-SES vs Target-SES =

On an ES5 platform, the SES initialization results in a object-capability system that can accept untrusted code without parsing or translation, and safely run it confined under object-capability rules. However, because of the means we use to secure it without parsing or translation, the language in which this untranslated code is written differs from SES in five minor ways, which we enumerate below. 

When we distinguish this untranslated almost-SES language from SES, we refer to the untranslated language as _Target-SES_ and real SES as _Source-SES_. At [http://code.google.com/p/google-caja/source/browse/trunk/experimental/src/com/google/caja/ses/expandProgramToExpr.js expandProgramToExpr.js] is pseudo-code explaining our translation from Source-SES to Target-SES. If you are writing using this translator in order to write in Source-SES, _and_ if all code of concern that you don't trust is also required to pass through the Source-SES to Target-SES translator, then you can ignore these five differences. Otherwise, they are relevant.

== Completion Value ==



== Top Level Declarations ==

== typeof _variable_ ==

== `this`-binding of Global Function Calls ==

== Safety of Thrown Values ==

= Browser and Platform Differences =

== Tamper Proofing vs Freezing, revisited ==