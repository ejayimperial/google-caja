#summary Documents differences between SES (Secure EcmaScript) and ES5 (EcmaScript 5).

= Introduction =

SES is mostly defined as a fail-stop subset of ES5 that should compatibly run all ES5 code that follows recognized ES5 best practices. The SES restrictions support the writing of defensively consistent abstractions -- object abstractions that can defend their integrity while being exposed to untrusted but confined objects.

This page is for hard core developers, to document precisely the differences between the various forms of SES, and how these differ from ES5.

= Idealized SES vs ES5 =

== Whitelist Primordial State ==

== No Monkey Patching Primordials ==

== Script Code vs Eval Code ==

== Powerless thrown Errors, etc. ==

== Extra APIs ==

=== !WeakMap, !StringMap ===

=== cajaVM ===

= SES-on-ES5 vs Idealized SES =

== Tamper Proofing vs Freezing ==

= SES vs CES (Confined !EcmaScript) =

== Waive Monkey Patching Prohibition ==

== Multi-Frame Operation ==

== Defensiveness Despite Monkey Patching ==

= Source SES vs Target SES =

== Completion Value ==

== Top Level Declarations ==

== typeof _variable_ ==

== `this`-binding of Global Function Calls ==

== Safety of Thrown Values ==

== Translations == 

We express our translations using !JavaScript [http://wiki.ecmascript.org/doku.php?id=harmony:quasis quasiliterals] and a hypothetical !JavaScript quasi-parser named "{{{js}}}". We additionally assume that the expression syntax {{{ {a, b} }}} is shorthand not for {{{ {a: a, b: b} }}} as currently proposed, but rather for 
{{{ 
  {
    get a() { return a; }, 
    set a(n) { a = n; }, 
    get b() { return b; },
    set b(n) { b = n; }
  }
}}}
as proposed at the end of [http://wiki.ecmascript.org/doku.php?id=strawman:object_initialiser_shorthand#discussion object initializer discussion section].

Together, this means that ({{{quasiParser`stuff${{varName}}stuff`}}}) can create an object that can be used as a pattern, placing the values extracted from the specimen into {{{varName}}}, which must have already been declared. As a further elaboration, we assume predicate pattern functions that wrap such a literal ({{{quasiParser`stuff${isThing({varName})}stuff`}}}) and report whether the proposed assignment meets it criteria. If not, that match fails.

Separately from the rules below, we also prohibit identifiers ending in {{{___}}} (triple underbar) in the input, so that we may use them in the output without fear of capture.

When a variable such as {{{fooIn}}} appears on the left and {{{fooOut}}} appears on the right, then {{{fooOut}}}'s value is {{{fooIn}}} as transformed by a recursive application of these rules.

The !JavaScript quasiParser accepts one additional element besides !JavaScript syntax and {{{$}}} holes. In addition, when an "{{{*}}}", "{{{+}}}", or "{{{?}}}" appears immediately to the right of a {{{$}}} hole with no intervening space, then it is taken as a quantifier on the binding of the {{{$}}} hole to consecutive AST elements.

Taking each of the above issues in order:

=== Completion Value ===

|| Source SES quasi-pattern || Target SES quasi-expression ||
|| {{{js`${isProgram({progIn})}; ${isExpr({eIn})}`}}} || {{{js`(function(global___) { $progOut; return $eOut; }).call(this, this);`}}} ||
|| {{{js`${isProgram({progIn})}`}}} || {{{js`(function(global___) { $progOut }).call(this, this);`}}} ||


=== Top Level Declarations ===

|| Source SES quasi-pattern || Target SES quasi-expression ||
|| {{{js`var ${isGlobal({name})};`}}} || {{{js`global___.$name` = void 0;`}}} ||
|| {{{js`var ${isGlobal({name})} = ${{eIn}};`}}} || {{{js`global___.$name = $eOut;`}}} ||

=== typeof _variable_ ===

|| Source SES quasi-pattern || Target SES quasi-expression ||
|| {{{js`typeof ${isFree({name})}`}}} || {{{js`($name in global___) ? typeof $name : 'undefined'`}}} ||

=== `this`-binding of Global Function Calls ===

|| Source SES quasi-pattern || Target SES quasi-expression ||
|| {{{js`${isGlobalOrFree({name})}(${{paramsIn}}*)`}}} || {{{js`$name.call(void 0, $paramsOut*)`}}} ||

=== Safety of Thrown Values ===

Ignore the line divisions below and the leading dots. It's just one rule and the dots should be leading spaces, but I don't know how to say this in a table in this wiki syntax.

|| Source SES quasi-pattern || Target SES quasi-expression ||
|| {{{js`try {}}}                                                   || {{{js`try {}}} ||
|| {{{.....${{tIn}} }}}                                              || {{{.....$tOut}}} ||
|| {{{...} catch (${mustNotShadow({param})}) {}}} || {{{...} catch (e___) { var $param = cleanErr___(e___);}}} ||
|| {{{.....${{cIn}} }}}                                              || {{{.....$cOut}}} ||
|| {{{...}` }}}                                                       || {{{...}` }}} ||

= Browser and Platform Differences =

== Tamper Proofing vs Freezing, revisited ==