#summary Documents differences between SES (Secure EcmaScript) and ES5 (EcmaScript 5).

_All mentions of "ES5" below actually refer to !EcmaScript 5.1_

= Introduction =

SES is mostly defined as a fail-stop subset of ES5 that should compatibly run all ES5 code that follows recognized ES5 best practices. The SES restrictions support the writing of defensively consistent abstractions -- object abstractions that can defend their integrity while being exposed to untrusted but confined objects.

This page is for hard core developers, to document precisely the differences between the various forms of SES, and how these differ from ES5. Introductory and tutorial material will appear elsewhere. _*where?*_

= ES6 extras: `WeakMaps` =

There is one crucial way in which SES is more than a subset of ES5 though still a subset of ES6 -- the inclusion of the [http://wiki.ecmascript.org/doku.php?id=harmony:weak_maps WeakMap abstraction] proposed for !EcmaScript 6. Over time, as more of ES6 settles down and becomes available in !JavaScript implementations, we expect to make more of these features available within SES as well. Note that `WeakMap` is always available in SES, whether or not it is available yet on the underlying !JavaScript platform. (When it does not derive from platform provided `WeakMap`s, the [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/WeakMap.js emulated WeakMaps] are necessarily leaky, but this is technically a quality of implementation issue rather than a correctness issue.)

= Idealized SES vs ES5 vs ES5 best practices =

== Strict and Non-Strict Code ==

By default, ES5 code is non-strict, which is compatible enough with legacy ES3 code in exhange for preserving most of the semantic minefields that make ES3 programming hell. For example, ES5 non-strict code, like ES3 code, is not lexically scoped, and in ways almost no one understood. Non-strict failed assignments are silent, allowing control flow to proceed on paths that assumed success.

So ES5 best practice is to always [http://wiki.ecmascript.org/doku.php?id=conventions:avoid_strictness_contagion opt-in to strict mode].

SES enforces that all SES code is strict, i.e., as if it had opted into strict mode, whether it does so explicitly or not. For ES5 code that follows ES5 best practices, this enforcement of strict code makes no difference.

== Whitelisted Primordial Properties ==

The notorious [http://es5.github.com/#x16 Chapter 16 exemptions] of the ES5 spec says that

  An implementation may provide additional types, values, objects, *_properties_*, and functions 
  beyond those described in this specification. This may cause constructs (such as looking up 
  a variable in the global scope) to have implementation-defined behaviour instead of throwing 
  an error (such as !ReferenceError).
_emphasis added_

Implementations do indeed make use of this freedom and provide all sorts of non-standard properties, many of which are semantically problematic (e.g., `RegExp.prototype.compile`, `RegExp.leftContext`), and that often differ from browser to browser (e.g., `__proto__`). Nevertheless, some properties that are not _de jure_ standards are unproblematic and universal, and have come to be recognized as harmless _de facto_ standards (e.g., `String.prototype.anchor`).

ES5 best practice limits code to relying only on such _de jure_ or harmless _de facto_ properties. While best practice code may attempt to use non-standard features when present, all such uses should be conditioned on feature tests for the presence of these properties, and the code should continue to work correctly in their absence.

SES is partially specified by its [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/whitelist.js whitelist], which includes all ES5 standard properties and those _de facto_ properties that we judge to be safe. SES guarantees the absence of any primordial properties that are absent from its whitelist. For ES5 code that follows ES5 best practices, these absences are unproblematic.

== Whitelisted Global Variables ==

Likewise, ES5 allows the global object to contain arbitrary properties, thereby defining arbitrary new global variables of the same names. The [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/whitelist.js SES whitelist] also defines what global variables are visible to SES code. The whitelisted globals include all the ES5 standard globals, the harmless _de facto_ standard *[http://es5.github.com/#B.2.1 escape]* and *[http://es5.github.com/#B.2.2 unescape]*, *`WeakMap`* as mentioned above, *[http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/ses/StringMap.js StringMap]*, which is a special case of the [http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets proposed ES6 Map], and (for now) the global *`cajaVM`*, which provides a collection of other SES and Caja specific additional APIs. Notably absent from SES itself are authority providing globals such as `document`, `window`, or `location`.

We do not intend to propose `cajaVM` itself be part of the future _de jure_ Ecma SES standard. Any functionality on `cajaVM` we wish to standardize, we will relocate and possibly refactor before proposing as a _de jure_ standard.

To write _platform independent_ !JavaScript code, i.e., code that is independent of whether its hosting environment is a browser, server, or whatever, ES5 best practice is to not rely on any non-standard globals. As with non-standard properties, best practice code may attempt to use such non-standard globals if present, but should condition such usage on feature testing whether those variables are present and have a value other than `undefined`, such as by testing
{{{
    if (typeof someConventionalGlobal === 'undefined') {
      // If someConventionalGlobal is either absent or has value undefined
      // Fallback behavior may simply be to terminate with an informative diagnostic
    } else {
      // If someConventionalGlobal is both present and has a non-undefined value
      // we may use it, assuming it has its conventional meaning
    }
}}}

Beyond the whitelisted globals, SES code may see additional global variable names depending on how it is spawned, including names like `document`, etc, which are bound to values emulating the traditional browser environment. _*We need to explain these spawning and scoping options somewhere*_

For ES5 best practice code that assumes (without testing) a hosting environment with additional globals, the SES code setting up the spawning environment can endow it with an emulation of the additional globals assumed by code expecting to run in that environment. Caja's [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/plugin/domado.js Domado library] provides just such a safe emulation of the browser environment.

== Only Standard Syntax ==

The notorious [http://es5.github.com/#x16 Chapter 16 exemptions] of the ES5 spec also says that

  An implementation may extend program syntax and regular expression pattern or flag 
  syntax. To permit this, all operations (such as calling eval, using a regular expression 
  literal, or using the Function or !RegExp constructor) that are allowed to throw !SyntaxError 
  are permitted to exhibit implementation-defined behaviour instead of throwing 
  !SyntaxError when they encounter an implementation-defined extension to the program 
  syntax or regular expression pattern or flag syntax.

When this additional syntax adds only sugar whose meaning is equivalent to code that could have been written in the standard language, it presents no great problem. However, this exemption allows non-standard syntax that could express non-standard semantics, including semantics that is [https://bugzilla.mozilla.org/show_bug.cgi?id=695579 impossible to secure]. Whereas programs can feature test for additional non-standard properties, as above, it is much more difficult (though possible using `eval`) to feature test for non-standard syntax.

ES5 best practice is to write code that uses only standard syntaxes.

SES accepts only standard syntax, or at most those non-syntactic elements of the underlying platform that are morally equivalent to sugar. For ES5 code that follows ES5 best practices, this restriction makes no difference. 

Note that the parser-free _Target-SES_ implementation explained below cannot prohibit non-standard syntaxes, but rather simply refuse to run if it detects the acceptance of specific non-standard syntaxes that it knows to worry about, [https://bugzilla.mozilla.org/show_bug.cgi?id=695577 such as E4X].

== No Monkey Patching Primordials ==

== No Mutable Globals ==

== Script Code vs Eval Code ==

== Direct and Indirect `eval`, and the `Function` Constructor ==

== Powerless thrown Errors, etc. ==

= SES-on-ES5 vs Idealized SES =

== Tamper Proofing vs Freezing ==

= SES vs CES (Confined !EcmaScript) =

== Waive Monkey Patching Prohibition ==

== Multi-Frame Operation ==

== Defensiveness Despite Monkey Patching ==

= Source-SES vs Target-SES =

See [http://code.google.com/p/google-caja/source/browse/trunk/experimental/src/com/google/caja/ses/expandProgramToExpr.js expandProgramToExpr.js] for pseudo-code explaining the translation from Source-SES to Target-SES.

== Completion Value ==

== Top Level Declarations ==

== typeof _variable_ ==

== `this`-binding of Global Function Calls ==

== Safety of Thrown Values ==

= Browser and Platform Differences =

== Tamper Proofing vs Freezing, revisited ==