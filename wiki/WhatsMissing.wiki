#labels Phase-Design
What common !EcmaScript elements are absent from Valija?

= Introduction =

Valija is approximately a subset of the ES3.1 "cautious" subset. But existing libraries are built for "consensus !JavaScript", also known as "ES3 + Reality" (hereafter "ES3R"), as represented by what browsers currently do. On this page we try to enumerate all features of ES3R not available in Valija, so that we can more quickly spot problem areas in porting old !JavaScript libraries to Valija.

Neither ES3.1 not Valija is settled yet, and actual browser behavior is determined only by ongoing experiment, so these lists are preliminary and fluid.


= Details =

== In ES3R but not codified by any expected standards document ==

  * *{{{Function.caller}}}*
  * *{{{Function.arguments}}}*
  * *{{{arguments.caller}}}*
  * *{{{__proto__}}}*

== In ES3 or ES3R but not in ES3.1 ==

  * *crazy scoping* -- ES3 specifies various gratuitous violations of lexical scoping that are crazy enough that most browsers often ignore the spec language and do something sensible instead.
    * *'as if by the expression "{{{new Array()}}}"'* -- if such language is interpreted literally, rebinding _or shadowing_ the {{{Array}}} literal will cause, for example, array literal expressions to use the local binding to {{{Array}}} rather than the original built-in Array constructor.
    * *try/catch* -- see Deviations document
    * *nested function expressions* -- as with try/catch, ES3 specifies that the name is brought into scope by adding a new object to the scope chain. Therefore, according to the spec language, properties on {{{Object.prototype}}} will shadow _lexical variables_ of those same name within the body of the nested function.
  * *Shared mutable !RegExp literal*

== In ES3.1, but not in the ES3.1 cautious subset ==

  * *{{{with}}}*
  * *{{{this}}}-promotion* -- when a function mentioning "{{{this}}}" is called as a function, or reflectively with its "thisArg" bound to null, occurrences of "{{{this}}}" in the function become bound instead to the global object. In ES3.1 cautious, such use of "{{{this}}}" will cause an exception to be thrown. In Valija, the "{{{this}}}" will simply evaluate to null with no promotion.
  * *{{{arguments.callee}}}*
  * *Joining of arguments array with parameter list*
  * *{{{delete}}} _<variable-name>_*

== The continued adventures of block-nested declarations ==

  * *nested {{{var}}} declarations*
  * *nested {{{const}}} declataions*
  * *nested {{{function}}} declarations*


== In ES3R and ES3.1 cautious, but not in Valija ==

  * *{{{eval()}}}*
  * *{{{Function()}}} constructor*
  * *All identifiers ending in an underscore ("{{{_}}}")*
  * *Distinction between a function's invoke behavior and its {{{call}}} or {{{apply}}} methods* -- In Valija, we translate all calls into calls to the {{{call}}} or {{{apply}}} method of the invoked thing, which need not itself be a function.
  * *Function members inherited from {{{Function.prototype}}}* --- {{{call}}}, {{{bind}}}, {{{apply}}}, and {{{length}}} are normally inherited from {{{Function.prototype}}}. In Valija, they are on each disfunction instance.

== In ES3.1 cautious but not yet in Valija ==

  * *Reflective attribute control* -- ES3.1 adds reflective attribute control operations on the {{{Object()}}} constructor.
  * *Decimal* -- ES3.1 adds a decimal floating point library as an arithmetic alternative to binary floating point.
  * *getters and setters*