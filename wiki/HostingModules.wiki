#summary Broad overview of creating host pages.
#labels Draft

*DRAFT* - This page is incomplete and may contain incorrect information.

So you want to write a host page — a web page which contains Caja modules. 

This page is intended to give a broad overview of the major moving parts, with enough technical detail to make informed choices. If you want a concrete explained example, see InteractingModulesExample.

= Types of [CajaCajole Cajoling] =

There are two ways cajoled code may be represented:

  * as a HTML file and !JavaScript file; the HTML is included in the host page by the server and the JavaScript referenced by a {{{<script>}}} element. This is the default.
	
	* as a single !JavaScript file. In this case, the first thing the cajoled code does is generate the HTML it originally came in (as if, but not actually, by {{{document.write}}}). To produce this type of output from the command-line {{{cajole_html}}}, use the {{{--only_js_emitted}}} option.

All of the examples here use the second method, because they do not use build systems or web servers to include the cajoler output in the host page.

== Cajita, Domita, and Valija ==

The Cajita runtime (cajita.js) is fundamental and must be loaded before any module.

TODO write the rest of this section

TODO explain Domita.

domita-minified.js includes cajita.js.

TODO explain Valija.

It is also possible for a module to have no HTML in it at all, such as if it were a !JavaScript library.

= Loading: the {{{<script>}}} problem =

The most straightforward way to load a module into a page is to include a {{{<script>}}} element referring to the cajoled !JavaScript.

However, Cajita modules execute in a chosen environment (imports) which determines the authority they get, in capability fashion, and they may have a return value. Some mechanism must be used to establish this association, since {{{<script>}}} merely gives access to JavaScript globals.

There are two primitive facilities available. One is the _new module handler_, which may be set by {{{___.setNewModuleHandler(...)}}}. This function will be called by the module when it is loaded, passing in the module object. The default new module handler (TODO explain how to create more) immediately instantiates the module, using a specific set of imports (which can be controlled with {{{handler.setImports(...)}}} and {{{handler.getImports()}}}).

The major problem with this mechanism is that it requires the correct ordering of a series of events (set up handler; load module; set up handler; load module; ...), even in the face of errors and asynchronicity.

The other primitive facility is that the [CajaCajole cajoler] may be directed to generate code which invokes another specified function, rather than the new module handler (in the style of JSONP). This has the advantage that there is no single global new-module-handler to be carefully managed; but it requires that the module be cajoled with an identifier unique within the loading page.

If you want to dynamically load modules and not worry about any of this, take a look at [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/cajita-module.js cajita-module.js], which implements a queue to manage {{{<script>}}} loading, and provides !XMLHTTPRequest-based loading as an alternative. Additionally, it presents a promise-based API for waiting for modules to load, and supports modules requesting other modules as dependencies.

= Host page examples =

All of these use the above-described “single JavaScript file” format of cajoled gadgets.

  * An utterly trivial example: CajaTrivialHost. This does nothing but load and display a gadget.

  * An example of “dynamically loading” gadgets: [http://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/demos/container/container-dynamic.html container-dynamic.html]. The code in this may in the future get folded into a convenience library for host pages.

  * Multiple gadgets, with interaction between them, are demonstrated with extensive comments at InteractingModulesExample.
  