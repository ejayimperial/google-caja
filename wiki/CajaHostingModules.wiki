#summary How to host Caja modules
= How to host a Caja module =

This document is intended for those who want to host Caja modules within pages that they serve.  If you simply want to write Caja modules for someone else to host, check out the Cajole docs.

Let's dive in!

{{{
0   <html>
      <head>
        <title>My Container</title>
      </head>
      <body>
        <h1>My Container</h1>

1       <script type="text/javascript" src="caja.js"></script>
        <script>
          // Here is some global data.
2         var someGuy = { name:"George" };

          var warn=function (x) { alert("Warning: " + x); };

          var html_sanitize = function (html) {
            // This implementation forbids the use of all tags except <BR>.
            var re=/^(\w|\s|\.|,|<BR>)*$/i;
            html = String(html);
            if (html.match(re)) return html;
            return "";
          }
        </script>

        <script>
          // ___.sharedOuters is the stuff that's common to all modules.
          // We make a copy so we can grant different capabilities to 
          // different modules.
3         var outers = ___.copy(___.sharedOuters);

          // "Taming" a global object is explicitly whitelisting permitted reads,
          // calls, sets, and deletes.

          // NOTE! Exposing too much can break the system entirely.  Don't allow
          // anything without consulting an object-capabilities/web-browser guru.

          // Let the module know about the someGuy object
4         outers.someGuy = someGuy;
          // Allow this module to read the name, but not to set it.
5         ___.allowRead(outers.someGuy, 'name');

          // Don't allow alert, but do allow indirect access to alert via warn()
6         outers.warn = warn;

          // DOM taming
          // Give the module a fake document object.
7         outers.document = {};

          // Put in a fake "document.write" method that sanitizes the html.
8         outers.document.write = function(html) {
            document.getElementById('my_shared_module_div').innerHTML +=
                html_sanitize(html);
          }

9         outers.document.getElementById = function(id) {
            // Tame the element before returning it.
10          var element = document.getElementById(id);

            // This stuff is harmless, so we allow it.
11          ___.allowCall(element, 'hasAttributes');
12          ___.allowRead(element, 'tagName');

13          // Instead of granting the capability to set innerHTML directly,
            // like this,
            //     ___.allowSet(element,'innerHTML')
            // we replace the setter with a sanitizer.  This technique is
            // called "wapping".
14          element.innerHTML_setter___ = function(html) {
              element.innerHTML = html_sanitize(html);
            };

            return element;
          };

          // Whitelist the document methods.
15        ___.allowCall(outers.document, 'getElementById');
16        ___.allowCall(outers.document, 'write');

          // The next two modules loaded after this will share the same
          // virtual global scope
17        ___.getNewModuleHandler().setOuters(outers);
        </script>

18      <div id="my_shared_module_div">
           <span id="span1">Hi there!</span>
        </div>

        <!-- Load the rewritten ("cajoled") modules.  
             Note that the scripts could be inlined instead! -->
19      <script src="myRewrittenModule.js"></script>
20      <script src="myOtherRewrittenModule.js"></script>

        <script>
          // Create a different virtual global scope.
21        var outers2 = ___.copy(___.sharedOuters);
          
22        outers2.phoneHome = function(hex) {
            hex = String(hex);
            var re = /^[A-F0-9]*$/;
            if (hex.match(re)) {
              var request = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("MSXML2.XMLHTTP.3.0");
              request.open("GET", "http://www.myserver.com/?hex="+hex, true);
              request.send();
            }
          }
          // The next module will see a different virtual global scope 
          // than the last two.  In particular, it has no way to
          // manipulate the DOM.
23        ___.getNewModuleHandler().setOuters(outers2);
        </script>
24      <script src="myThirdRewrittenModule.js"></script>
      </body>
    </html>
}}}

A Caja module container is an HTML document (0).  It must do four things:
  * Load the caja library before loading any modules. (1)  
  * Define a javascript object to express the security policy for modules. (3)
  * Tell the caja library about the object. (17) (23)
  * Load the modules (19) (20) (24); it can do this either by using a script tag:
    {{{
  <script src="myRewrittenModule.js"></script>
    }}}
  or it can use a template language to inline the code:
    {{{
  <script><% MY_REWRITTEN_MODULE %></script>
    }}}
  or a module can be hardcoded into the page:
    {{{
  <script>
  ___.loadModule(function(___OUTERS___){
    /* rest of rewritten code here... */
  });
  </script>
    }}}

The browser environment comes with several predefined standard global objects, like the DOM tree, Object, Array, Date, Math, etc.  Most containers also define global objects, like information about the currently logged-in user.  To enforce the principle of least authority, these objects will usually need to be restricted in some way.  The caja runtime provides safe versions of the standard objects as properties of ___.sharedOuters.

The best way to control access is to define it in a module; then the code is guaranteed to follow object capability rules.  When working with legacy code, however, cajoling the code into a module may be difficult.

Legacy code, then, will typically be either _tamed_ or _wrapped_.  _Taming_ an object is whitelisting calls, sets, and reads of the object's properties; a direct reference to the object is provided, but runtime checks are performed before allowing any of these actions.  The direct reference is placed into the virtual global scope of the module, called the "outers."  Typically, we make a copy of the standard objects (3) and add references to the copy.  Any property of outers can be read, set, or called by module code, but actions that affect properties of other objects need to be explicitly whitelisted.

In this example, someGuy is an object with a single property, name.  We'd like it to be a constant, so we need to tame it.  First, we put a reference to someGuy into outers (4).  Next, we whitelist the ability to read someGuy's name (5).  The call to allowRead sets the flag someGuy.name_canRead___ to true; any attempt to read someGuy.read within translated module code checks this flag before continuing.

The function warn() allows a module to put up an alert box, but prefaces the message with a fixed string.  Since alert() is not included in ___.sharedOuters, modules cannot pop up boxes unless we grant them the capability to do so.  Simply putting a reference to the function warn() in outers (6) is sufficient to allow it to be called from within module code.

Many modules will want to manipulate their DOM tree after they have been loaded.  We do not want to allow arbitrary calls to document.write; that's far too much authority.  Instead, we allow the modules to manipulate the inner HTML of "my_shared_module_div" (18).  First, we create an empty object in the virtual global scope and call it document (7).  This gives the illusion of being in a browser context to the module code.  Next, we add some methods to outers.document and whitelist them.

The function outers.document.write() (8) only allows the use of BR tags, alphanumeric strings, and a bit of punctuation.  This is very strict sanitization.  It's possible to allow far more, but it becomes very complicated to do so safely.

The function outers.document.getElementById() (9) returns a direct reference to the DOM element (10), but the caja runtime will prevent any reads, assignments, or calls to properties of the element at runtime unless we whitelist the actions (11) (12).  Just as with document.write(), allowing a module to assign to the innerHTML property directly is far too much authority, so we want to sanitize first.  Caja provides a way to intercept property assignments through the use of the "*_setter___" properties.  Since we did not explicitly say
{{{
___.allowSet(element.innerHTML);
}}}
when a module attempts to set it, the runtime check will fail and will call innerHTML_setter___ instead.

Finally, we whitelist outers.document.getElementById() (15) and outers.document.write() (16).

Now we can tell the Caja runtime about the virtual global scope we've defined (17).  ___.getNewModuleHandler() gets the handler for new modules; setOuters(outers) makes the handler use our virtual global scope for every module that's loaded after this point (at least, until we call setOuters() again).

Here, we load two modules by referencing the rewritten javascript in the src attribute of script tags (19) (20).  To reduce latency, the scripts could have been inlined here.  Both scripts will share the same virtual global scope.  Any "global" variable defined in one will be visible to the other.

Once these two modules have finished executing, we'd like to load a module that does not interact at all with the DOM; instead it performs a calculation and then sends the result to a fixed URL.  We make a new copy of ___.sharedOuters (21) and equip it with a phoneHome() method (22); it coerces its input to a string, verifies that it consists exclusively of hexadecimal digits, and then issues the request on behalf of the module.  The other two modules do not have access to this function, just as this module will not have access to the DOM.

We tell Caja about the new outers2 object with setOuters() (23) and load the third module (24).  When it has finished executing, all further activity within modules will be driven by user actions.