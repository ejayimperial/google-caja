#summary Program transformations that turn javascript into Caja
#labels Phase-Design

= Background =

Caja is a syntactic and semantic subset of JavaScript but the dynamic
nature of JavaScript prevents us from statically recognizing all
prohibited code.  Instead we perform two types of transformations --
we statically recognize and reject non-Caja input when we can and we
rewrite the remaining program with additional runtime checks.

= Transformations =

Cajoling rules are specified using QuasiLiterals to identify the snippet
of code which needs to be rewritten and what it is to be replaced with.
==Default set of transformations used by Caja==
|| ||Rule||Synopsis||Reason||Matches||Substitutes||
||0||module||Disallow top-level "this". Import free variables.||In Caja, "this" may only be bound to an object when within the object's encapsulation boundary. At top-level level, "this" would be bound to the provided imports object, but the module is outside that object's encapsulation boundary.||{{{@ss*;}}}||{{{@startStmts*; @ss*;}}}||
||1||synthetic||Pass through synthetic nodes.||Allow a relied-upon (trusted) translator to supply JavaScript code to be included in the output with no further translation.||{{{<@synthetic>}}}||{{{<@synthetic>}}}||
||2||block||Initialize named functions at the beginning of their enclosing block.||Nested named function declarations are illegal in ES3 but are universally supported by all JavaScript implementations, though in different ways. The compromise semantics currently supported by Caja is to hoist the declaration of a variable with the function's name to the beginning of the enclosing function body or module top level, and to initialize this variable to a new anonymous function every time control re-enters the enclosing block. Note that ES3.1 and ES4 specify a better and safer semantics -- block level lexical scoping -- that we'd like to adopt into Caja eventually. However, it so challenging to implement this semantics by translation to currently-implemented JavaScript that we provide something quicker and dirtier for now.||{{{{@ss*;}}}}||{{{@startStmts*; @ss*;}}}||
||3||with||Statically reject if a `with` block is found.||`with` violates the assumptions made by Scope, and makes it very hard to write a Scope that works. http://yuiblog.com/blog/2006/04/11/with-statement-considered-harmful/ briefly touches on why `with` is bad for programmers. For reviewers -- matching of references with declarations can only be done at runtime. All other secure JS subsets that we know of (ADSafe, Jacaranda, & FBJS) also disallow `with`.||{{{with (@scope) @body;}}}||{{{<reject>}}}||
||4||foreach||Only enumerate Caja-visible and enumerable property names. A for-in on "this" will see pubic and protected property names. Otherwise, only public property names.||To enumerate any other property names would be to violate the object's encapsulation, leak internals of the Caja implementation, or violate taming decisions of what should be visible.||{{{for (@k in @o) @ss;}}}||{{{<approx> for (@k in @o) { if (___.@canEnum(@o,@k)) @ss}}}||
||5||tryCatch||Ensure that only immutable data is thrown, and repair scope confusion in existing JavaScript implementations of try/catch.||When manually reviewing code for vulnerability, experience shows that reviewers cannot pay adequate attention to the pervasive possibility of thrown exceptions. These lead to four dangers: 1) leaking an authority-bearing object, endangering integrity, 2) leaking a secret, endangering secrecy, and 3) aborting a partially completed state update, leaving the state malformed, endangering integrity, and 4) preventing an operation that was needed, endangering availability. Caja only seeks to make strong claims about integrity. By ensuring that only immutable (transitively frozen) data is thrown, we prevent problem #1. For the others, programmer vigilance is still needed.  Current JavaScript implementations fail, in different ways, to implement the scoping of the catch variable specified in ES3. We translate Caja to JavaScript so as to implement the ES3 specified scoping on current JavaScript implementations.||{{{try { @s0*; } catch (@x) { @s1*; }}}}||{{{try {  @s0*;} catch (ex___) {  try {    throw ___.tameException(ex___);   } catch (@x) {    @s1*;  }}}}}||
||6||tryCatchFinally||Finally adds no special issues beyond those explained in try/catch.||Caja is not attempting to impose determinism, so the reasons for Joe-E to avoid finally do not apply.||{{{try { @s0*; } catch (@x) { @s1*; } finally { @s2*; }}}}||{{{try {  @s0*;} catch (ex___) {  try {    throw ___.tameException(ex___);  } catch (@x) {    @s1*;  }} finally {  @s2*;}}}}||
||7||tryFinally||See bug 383. Otherwise, it's just the trivial translation.||try/finally actually seems to work as needed by current JavaScript implementations.||{{{try { @s0*; } finally { @s1*; }}}}||{{{try { @s0*; } finally { @s1*; }}}}||
||8||varArgs||Make all references to the magic "arguments" variable into references to a frozen array containing a snapshot of the actual arguments taken when the function was first entered.||ES3 specifies that the magic "arguments" variable is a dynamic ("joined") mutable array-like reflection of the values of the parameter variables. However, te typical usage is to pass it to provide access to one's original arguments -- without the intention of providing the ability to mutate the caller's parameter variables. By making a frozen array snapshot with no "callee" property, we provide the least authority assumed by this typical use.  The snapshot is made with a "var a___ = ___.args(arguments);" generated at the beginning of the function body.||{{{arguments}}}||{{{a___}}}||
||9||varThis||Translates all occurrences of "this" to "t___".||The translation is able to worry less about the complex scoping rules of "this". In a function mentioning "this", a "var t___ = this;" is generated at the beginning of the function body.||{{{this}}}||{{{t___}}}||
||10||varBadSuffix||Statically reject if a variable with `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{@v__}}}||{{{<reject>}}}||
||11||varBadSuffixDeclaration||Statically reject if a variable with `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{<approx>(var|function) @v__ ...}}}||{{{<reject>}}}||
||12||varBadImportSuffix||Statically reject if an imported variable with `_` suffix is found||A module is outside the encapsulation boundary of its imports object, and so cannot address any of that object's protected properties.||{{{@import_}}}||{{{<reject>}}}||
||13||varFuncFreeze||An escaping occurence of a function name freezes the function.||By adopting this static rule, we only need to generate freezes for names that are statically known to be function names, rather than freezing at every potential point of use.||{{{@fname}}}||{{{___.primFreeze(@fname)}}}||
||14||varDefault||Any remaining uses of a variable name are preserved.|| ||{{{@v}}}||{{{@v}}}||
||15||readBadSuffix||Statically reject if a property has `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{@x.@p__}}}||{{{<reject>}}}||
||16||readInternal||Read a public or protected property.||Since it is addressed from "this.", Caja assumes we are inside the encapsulation boundary of the object bound to "this", and so its protected properties should be accessible.||{{{this.@p}}}||{{{<approx> ___.readProp(t___, @'p')}}}||
||17||readBadInternal||Statically reject public reading of a property ending with '_'.||Caja defines variable with a `_` suffix as protected.||{{{@x.@p_}}}||{{{<reject>}}}||
||18||readPublic|| || ||{{{@o.@p}}}||{{{<approx> ___.readPub(@o, @'p')}}}||
||19||readIndexInternal|| || ||{{{this[@s]}}}||{{{___.readProp(t___, @s)}}}||
||20||readIndexPublic|| || ||{{{@o[@s]}}}||{{{___.readPub(@o, @s)}}}||
||21||setBadAssignToFunctionName||Statically reject if an assignment expression assigns to a function name.|| ||{{{<approx> @fname @op?= @x}}}||{{{<reject>}}}||
||22||setBadThis||Statically reject if an expression assigns to `this`.||Invalid JavaScript.||{{{this = @z}}}||{{{<reject>}}}||
||23||setBadFreeVariable||Statically reject if an expression assigns to a free variable.||This is still controversial (see bug 375). However, the rationale is to prevent code that's nested lexically within a module to from introducing mutable state outside its local function-body scope. Without this rule, two nested blocks within the same module could communicate via a pseudo-imported variable that is not declared or used at the outer scope of the module body.||{{{@import = @y}}}||{{{<reject>}}}||
||24||setBadSuffix||Statically reject if a property with `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{@x.@p__ = @z}}}||{{{<reject>}}}||
||25||setInternal||Set or create a public or protected property.||We allow methods and constructors within a constructed object to create new properties on itself directly by assignment.||{{{this.@p = @r}}}||{{{<approx> ___.setProp(t___, @'p', @r)}}}||
||26||setMember||Initialize a member of the prototypical object associated with a constructor or named function, to be inherited by the instances of that function.||The right hand side of this rule is a "method context" -- a position in which Caja methods can appear. This allows unattached methods to be stored in the prototypical object, which is necessary for allowing instances to share these. However, any attempt to obtain access to a method as a value will obtain at most an attached method.||{{{@df.prototype.@p = @m}}}||{{{___.setMember(@df, @'p', @m)}}}||
||27||setBadInternal||Cannot publicly access a property ending with '_'.||Caja defines variable with a `_` suffix as protected.||{{{@x.@y_ = @z}}}||{{{<reject>}}}||
||28||setStatic||Initialize the direct properties (static members) of a potentially-mutable constructor or named function.|| ||{{{@fname.@p = @r}}}||{{{___.setStatic(@fname, @'p', @r)}}}||
||29||setPublic||Set a public property.||If the object is an unfrozen JSONContainer (a record or array), then this will create the own property if needed. If it is an unfrozen constructed object, then clients can assign to existing public own properties, but cannot directly create such properties.||{{{@o.@p = @r}}}||{{{<approx> ___.setPub(@o, @'p', @r);}}}||
||30||setIndexInternal|| || ||{{{this[@s] = @r}}}||{{{___.setProp(t___, @s, @r)}}}||
||31||setIndexPublic|| || ||{{{@o[@s] = @r}}}||{{{___.setPub(@o, @s, @r)}}}||
||32||setBadInitialize||Statically reject if a variable with `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{var @v__ = @r}}}||{{{<reject>}}}||
||33||setInitialize||Ensure v is not a function name. Expand the right side.|| ||{{{var @v = @r}}}||{{{var @v = @r}}}||
||34||setBadDeclare||Statically reject if a variable with `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{var @v__}}}||{{{<reject>}}}||
||35||setDeclare||Ensure that v isn't a function name.|| ||{{{var @v}}}||{{{var @v}}}||
||36||setBadVar||Statically reject if a variable with `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{@v__ = @r}}}||{{{<reject>}}}||
||37||setVar||Only if v isn't a function name.|| ||{{{@v = @r}}}||{{{@v = @r}}}||
||38||setReadModifyWriteLocalVar|| || ||{{{@x @op= @y}}}||{{{<approx> @x = @x @op @y}}}||
||39||setIncrDecr||Handle pre and post ++ and --.|| ||{{{UNKNOWN}}}||{{{UNKNOWN}}}||
||40||newCalllessCtor||Add missing empty argument list.||JavaScript syntax allows constructor calls without "()".||{{{new @ctor}}}||{{{<expand> new @ctor()}}}||
||41||newCtor|| || ||{{{new @ctor(@as*)}}}||{{{new (___.asCtor(@ctor))(@as*)}}}||
||42||deleteBadSuffix|| || ||{{{delete @o.@p__}}}||{{{<reject>}}}||
||43||deleteInternal|| || ||{{{delete this.@p}}}||{{{___.deleteProp(t___, @'p')}}}||
||44||deleteBadInternal|| || ||{{{delete @o.@p_}}}||{{{<reject>}}}||
||45||deletePublic|| || ||{{{delete @o.@p}}}||{{{___.deletePub(@o, @'p')}}}||
||46||deleteIndexInternal|| || ||{{{delete this[@s]}}}||{{{___.deleteProp(t___, @s)}}}||
||47||deleteIndexPublic|| || ||{{{delete @o[@s]}}}||{{{___.deletePub(@o, @s)}}}||
||48||deleteNonProperty|| || ||{{{delete @v}}}||{{{<reject>}}}||
||49||callBadSuffix||Statically reject if a selector with `__` suffix is found.||Caja reserves the `__` suffix for internal use.||{{{@o.@p__(@as*)}}}||{{{<reject>}}}||
||50||callInternal|| || ||{{{this.@p(@as*)}}}||{{{<approx> ___.callProp(t___, @'p', [@as*]}}}||
||51||callBadInternal||Statically reject if a public selector with `_` suffix is found.||Caja defines selectors with a `_` as private.||{{{@o.@s_(@as*)}}}||{{{<reject>}}}||
||52||callCajaDef2||Declares that the first argument acts as a derived constructor inheriting from the second.||Sets up a well formed prototype inheritance chain between these two functions. The first argument must be a declared function name. Calling caja.def() on it does not freeze it.||{{{caja.def(@fname, @base)}}}||{{{caja.def(@fname, @base)}}}||
||53||callCajaDef2BadFunction||Reject calls to caja.def() on names of functions statically known to be frozen.||Within a function foo(), foo must already be frozen, so it is too late to initialize it.||{{{caja.def(@fname, @base)}}}||{{{<reject>}}}||
||54||callCajaDef2Bad||Reject other calls to caja.def().||If the first argument is not a declared function name, then it cannot be an unfrozen function.||{{{caja.def(@x, @base)}}}||{{{<reject>}}}||
||55||callCajaDef3Plus||Declare an inheritance relationship, and initialize methods and statics.||The enumerable own properties of the third and fourth arguments, if present are used to initialize @fname.prototype and @fname, respectively. The third argument must statically be an object-literal expression. The value positions of this expression is a method context -- a position in which methods are allowed.||{{{caja.def(@fname, @base, @mm, @ss?)}}}||{{{caja.def(@fname, @base, @mm, @ss?)}}}||
||56||callCajaDef3PlusBadFunction||Reject initialization of a name of a function statically known to be frozen.|| ||{{{caja.def(@fname, @base, @mm, @ss?)}}}||{{{<reject>}}}||
||57||callCajaDef3PlusBad||Reject other calls to caja.def().|| ||{{{caja.def(@x, @base, @mm, @ss?)}}}||{{{<reject>}}}||
||58||callFuncInlineMethodCall|| || ||{{{(function (@formals*) { @body*; }).call(this, @args*);}}}||{{{(function (@formals*) { @fh*; @stmts*; @body*; }).call(this, @args*);}}}||
||59||callFuncInlineMethodApply|| || ||{{{(function (@formals*) { @body*; }).apply(this, @arg);}}}||{{{(function (@formals*) { @fh*; @stmts*; @body*; }).apply(this, @arg);}}}||
||60||callFuncInlineMethodBind|| || ||{{{(function (@formals*) { @body*; }).bind(this, @args*);}}}||{{{(function (@formals*) { @fh*; @stmts*; @body*; }).bind(t___, @args*);}}}||
||61||callPublic|| || ||{{{@o.@p(@as*)}}}||{{{<approx> ___.callPub(@o, @'p', [@as*])}}}||
||62||callIndexInternal|| || ||{{{this[@s](@as*)}}}||{{{___.callProp(t___, @s, [@as*])}}}||
||63||callIndexPublic|| || ||{{{@o[@s](@as*)}}}||{{{___.callPub(@o, @s, [@as*])}}}||
||64||callFunc|| || ||{{{@f(@as*)}}}||{{{___.asSimpleFunc(@f)(@as*)}}}||
||65||funcAnonSimple|| || ||{{{function (@ps*) { @bs*; }}}}||{{{___.primFreeze(  ___.simpleFunc(    function (@ps*) {      @fh*;      @stmts*;      @bs*;}))}}}||
||66||funcNamedSimpleDecl|| || ||{{{function @fname(@ps*) { @bs*; }}}}||{{{@fr = ___.simpleFunc(  function @fname(@ps*) {    @fh*;    @stmts*;    @bs*;});}}}||
||67||funcNamedSimpleValue|| || ||{{{function @fname(@ps*) { @bs*; }}}}||{{{___.primFreeze(  ___.simpleFunc(    function @fname(@ps*) {      @fh*;      @stmts*;      @bs*;  }));}}}||
||68||funcXo4a||Rewrites an 1) anonymous function 2) mentioning this 3) whose earliest function scope ancestor is NOT a constructor or method into an exophoric function.||A moderately risky stepping stone to ease the conversion of old code.||{{{(function (@formals*) { @body*; })}}}||{{{<approx> ___.xo4a(function (@formals*) { @fh*; @stmts*; @body*; })}}}||
||69||funcCtor|| || ||{{{function @fname(@ps*) { @b; @bs*; }}}}||{{{<approx> @fname = (function () {  ___.splitCtor(@fRef, @f_init___Ref);  function @fname(var_args) { return new @fRef.make___(arguments); }  function @f_init(@ps*) {    @fh*;    @stmts*;    @b;    @bs*;  }  return @fRef;})()}}}||
||70||mapEmpty|| || ||{{{({})}}}||{{{({})}}}||
||71||mapBadKeySuffix||Statically reject if a key with `_` suffix is found|| ||{{{<approx> ({@keys_*: @vals*})}}}||{{{<reject>}}}||
||72||mapNonEmpty|| || ||{{{({@keys*: @vals*})}}}||{{{({@keys*: @vals*})}}}||
||73||multiDeclaration|| || ||{{{UNKNOWN}}}||{{{UNKNOWN}}}||
||74||otherInstanceof|| || ||{{{@o instanceof @f}}}||{{{@o instanceof @f}}}||
||75||otherTypeof|| || ||{{{typeof @f}}}||{{{<approx> typeof ___.readPub(IMPORTS___, @'f')}}}||
||76||otherSpecialOp|| || ||{{{UNKNOWN}}}||{{{UNKNOWN}}}||
||77||labeledStatement||Statically reject if a label with `__` suffix is found||Caja reserves the `__` suffix for internal use||{{{UNKNOWN}}}||{{{UNKNOWN}}}||
||78||regexLiteral||Use the regular expression constructor||So that every use of a regex literal creates a new instance to prevent state from leaking via interned literals.  This is consistent with the way ES4 treates regex literals.||{{{UNKNOWN}}}||{{{new ___.RegExp(@pattern, @modifiers?)}}}||
||79||recurse||Automatically recurse into some structures|| ||{{{UNKNOWN}}}||{{{UNKNOWN}}}||