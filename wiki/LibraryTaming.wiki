#summary How to tame libraries.

*(This page is under construction)*

= Introduction =

Ideally any library you use will be included prior to Cajoling, and so will "just work" and will not need to be tamed.

However, libraries sometimes provide facilities which cannot be provided using the safe subset of Javascript that Caja provides. In that case, the library will have to be run outside the Cajoled code, within your container, and an interface to the library provided to Cajoled code. This process is known as "taming".

= Taming =

== Exposing The Library ==

First of all, the Cajoled code needs some means to access the library. In your container you should have some code looking something like this

{{{
  var imports = ___.copy(___.sharedImports);
  imports.outers = imports;
  imports.$v = ___.asFunc(valijaMaker)(imports);
  ___.getNewModuleHandler().setImports(imports);
}}}

Anything you attach to `imports` becomes a "global" variable in the scope of the Cajoled gadget (remembering that Caja rewrites globals to become properties of the `imports` object).

So, let's say that your library is exposed to your container through some object called `mylibrary`. The simplest thing to do is to expose that object like so

{{{
imports.mylibrary = mylibrary;
}}}

Now the Cajoled code can see the library, but it has no access to properties yet, these must be individually granted.

== Taming simple arguments ==

Suppose your library exposes a property called `someProperty`.  You can grant a cajoled program read access to `someProperty` like this:

{{{
___.grantRead(mylibrary, 'someProperty');
}}}

This would allow the Cajoled code to read `mylibrary.someProperty` but not to write or execute it. Similarly you can grant write access with `___.grantSet(object, 'property')` and call access with `___.grantCall(object, 'property')`. Constructors are a little more complex, these are done with `___.ctor(class, parent, 'classname')`.

== Taming callbacks and functions as arguments ==

Some functions which you want to tame take other functions as parameters or return functions as results.  Taming these functions is slightly more involved.  Suppose you want to tame the following function in your library:

{{{
  function registerCallback(callback) {
    var result = someOperation();
    callback(result);
  }
}}}

When a cajoled program calls `registerCallback`, the `callback` function it passes as an argument has already been cajoled.  Caja cajoled functions to an object literal which has three properties, `call`, `bind` and `apply`.  In order for your library to correctly call `callback`, it needs to know whether `callback` has been cajoled in cajita or valija mode and what the occurrences of the keyword `this` in `callback` should be bound to.  Remember that your taming code is not cajoled and thus wields an uncontrolled amount of  authority.  In particular, the default binding for occurrences of `this` is the global object `window`, and naively granting `callback` access to the global object will allow a cajoled program to break out of its sandbox completely.  The safe and recommended taming of a callback function like the one above would be to bind occurrences of `this` inside `callback` to something that was useless and granted no additional authority.  The caja library provides one such object called `USELESS`.  Suppose the `callback` function is cajoled in _cajita mode_ and expects one argument.  We can tame is as follows:

{{{
   function tameRegisterCallack(callback) {
     var result = someOperation();
     callback.call(USELESS, result);
}}}

All functions cajoled in _valija mode_ take an additional first parameter called `$dis`.  This is the global scope as perceived by that function.  In almost all circumstances, you want this perceived global scope to also be USELESS.  Thus if `callback` is cajoled in _valija mode_,  the appropriate taming for `registerCallback` is:

{{{
   function tameRegisterCallack(callback) {
     var result = someOperation();
     callback.call(USELESS, USELESS, result);
}}}

== Taming functions as returns values ==

Similarly, your library function may return a function itself.  For example:
{{{
   function makeAdder() {
     return function(s) { return s+1; }  
   }
}}}

In this case, taming your library by marking `makeAdder` callable is not sufficient because the function it returns will not itself be callable by a cajoled program.  The solution is to tame `makeAdder` by marking the result it returns as callable:

{{{
  function tameMakeAdder() {
    return ___.func(makeAdder());
  }
}}}


== Caveats while taming libraries ==

Obviously because the library you have exposed is not cajoled, it could do anything. So, you must ensure that it doesn't do anything that would allow the cajoled code to break out of its sandbox.

Firstly, only grant permissions to things you absolutely have to grant permissions to.

Secondly, anything you do grant permission to has to be carefully reviewed to make sure it is safe. Things to avoid are

  * Use of `eval()` on anything controlled by the caller.
    * If `eval()` is really necessary then you must construct what is evaled very carefully to ensure it cannot be abused by the caller.
  * Setting `innerHTML` on DOM nodes. Any caller-controlled input must be sanitised to avoid the use of script tags and the like. The easiest way to do this is to use the HTML sanitizer supplied with Caja _need reference for how to do this_.

Sometimes the easiest way to deal with these issues (especially if the library is a third-party library) is to wrap the dangerous functions in functions of your own that sanitized or otherwise restrict the inputs to the "real" functions.