#summary Differences between ES5/3 and ES5

= Introduction =

We're working on an implementation of ES5 that runs on ES3 browsers; we anticipate that this implementation, which we call "ES5/3", will take the place of Valija; we anticipate it will run around 15 times faster.  SES5/3, the Cajita replacement, is exactly the same with the exception of freezing all the primordials.

SES5/3 will upwards compatible from Cajita. ES5/3 will be upwards compatible from Valija, Cajita, and SES5/3. 

There will be some differences between ES5/3 and ES5, detailed below. For code written with these in mind, ES5 will effectively be upwards compatible from ES5/3, etc...

= Differences between ES5/3 and ES5 =

  * Strict mode only
  * Does not support FF2
  * No eval
  * No Function constructor
  * All numeric properties share one property descriptor
  * Numeric properties must be data properties
  * 'length' is a non-configurable accessor property on arrays
  * 'length' must not be an accessor property on non-arrays
  * Object.prototype is frozen
  * The true global object is inaccessible
  * Property names may not end in two underscores
  * Does not support creating objects with null prototype
  * Only supports bracketed numeric indexing into strings if the underlying ES3 engine does
  * If a variable is statically known to contain only numbers after being initialized and it is used as a property name before initialization, then it may be converted to the property name 'NaN' rather than the property name 'undefined'.

ES Harmony

  * Proxies
    * Proxies can only inherit, whether directly or indirectly, from non-extensible objects or from other proxies.
    * Proxies can't trap numeric properties or 'length'
  * "Leaky" ephemeron tables
    * Membranes hold onto all references that they wrap until the membrane is revoked