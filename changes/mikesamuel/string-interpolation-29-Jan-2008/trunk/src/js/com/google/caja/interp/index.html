<html>
<head>
<title>Secure String Interpolation</title>
<style type=text/css>
.todo { color:red; font-size: 300% }
.spreadsheet td { text-align: center }
.annotated { border: 1px dotted #888 }
td > pre { margin-bottom: 0; padding-bottom: 0 }
.changed { background: #eef }
</style>

<link type="text/css" rel="stylesheet"
 href="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.css" />
<script type="text/javascript"
 src="http://google-code-prettify.googlecode.com/svn/trunk/src/prettify.js"
></script>

<script type="text/javascript">
function makeToc(tocContainer, contentContainer) {
  var idCounter = 0;
  function allocateId() {
    return '-autogen-id-' + (++idCounter);
  }
  function innerTextOf(node) {
    var sb = [];
    innerTextToBuffer(node, sb);
    return sb.join('');
  }
  function innerTextToBuffer(node, out) {
    if (node.nodeType === 3) {
      out.push(node.nodeValue);
    } else {
      for (var c = node.firstChild; c; c = c.nextSibling) {
        innerTextToBuffer(c, out);
      }
    }
  }

  var toc = document.createElement('ol');
  var listStack = [toc];
  for (var c = contentContainer.firstChild; c; c = c.nextSibling) {
    if (!/^h[2-6]$/i.test(c.nodeName)) { continue; }
    if (!c.id) { c.id = allocateId(); }
    var depth = Number(c.nodeName.substring(1)) - 1;
    if (listStack.length > depth) {
      listStack.length = depth;
    } else {
      while (listStack.length < depth) {
        var item = listStack[listStack.length - 1].lastChild;
        if (!item) {
          item = document.createElement('li');
          listStack[listStack.length - 1].appendChild(item);
        }
        var subList = document.createElement('ol');
        item.appendChild(subList);
        listStack.push(subList);
      }
    }
    var item = document.createElement('li');
    var link = document.createElement('a');
    link.appendChild(document.createTextNode(innerTextOf(c)));
    link.href = '#' + c.id;
    item.appendChild(link);
    listStack[listStack.length - 1].appendChild(item);
  }
  tocContainer.appendChild(toc);
}
</script>

</head>
<body bgcolor=white
 onload="makeToc(document.getElementById('table-of-contents'), document.body);
         prettyPrint()">

<h1>Secure String Interpolation in JS</h1>

<div id=table-of-contents></div>

<h2>Abstract</h2>

<p><a
href="http://en.wikipedia.org/wiki/Variable#Variable_interpolation"
>String Interpolation</a>, the <code>"Hello $name_of_planet!"</code>
style of generating strings, familiar to Perl, PHP, and Ruby
programmers, provides a simple and intuitive way of specifying content
in many languages from HTML to SQL to URLS.

<p>It also makes it very easy to introduce serious security problems.
<a href=http://en.wikipedia.org/wiki/SQL_injection><i>SQL Injection</i></a>,
<a href=http://en.wikipedia.org/wiki/Code_injection><i>Script Injection</i></a>,
<a href=http://archive.cert.uni-stuttgart.de/bugtraq/2002/10/msg00421.html
><i>XML External Entity Injection</i></a> (XXE), and <a href=
"http://en.wikipedia.org/wiki/Cross_site_scripting#Avoiding_XSS_vulnerabilities"
><i>Cross Site Scripting</i></a> (XSS) attacks are results of a
failure to properly escape user-supplied data before splicing it into
a web-page, a SQL query, or a shell command.</p>

<p>These problems are not inherent to String Interpolation though.
The strings themselves contain more than enough information to figure
out how to safely incorporate user data.  Consider the code snippet:

<blockquote><pre class=prettyprint>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello <b>$name_of_planet</b>!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;We come in peace.&lt;/h1&gt;
    &lt;p&gt;Take us to your
      &lt;abbr title="May (s)he live for many <b>$time_units</b>!"&gt;
        <b>$title_of_potentate</b>
      &lt;/abbr&gt;.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre></blockquote>

<p>It should be clear that the programmer intended the substitutions
<code>$name_of_planet</code> and <code>$title_of_potentate</code> to
be text in an html page, and that <code>$time_units</code> is part of
an HTML attribute.  Obviously, the browser can handle all those
distinctions when the time comes to render a page, but at the time the
string interpolation is executed, it has no way to tell that one
string is HTML, and another is not.  The problem is one of early
binding &mdash; acting before enough information is available to make
good decisions.</p>

<p>Below I discuss the benefits of string interpolation, outline some
of the alternatives to string interpolation, show how interpolation
can benefit from late binding, and explain how it can be bolted onto
languages like Javascript.  I use Javascript throughout the examples
since Javascript examples can be run in browser, but the security
problems discussed herein occur in code written in many languages.



<h2>Injection Errors Among The Most Common Vulnerabilities</h2>

<p><a href="http://cve.mitre.org/docs/docs-2007/unforgivable.pdf"
><tt>Mitre.org</tt>'s "Unforgivable Vulnerabilities"</a> lists XSS,
and SQL injection vulnerabilities as the 2nd and 3rd most frequent
security vulnerabilities in applications they audited.  Since web
applications aren't vulnerable to the number 1 vulnerability, buffer
overflows, XSS problems seem the most important security hole to
address.  <a href="http://code.google.com/apis/gears/api_database.html"
>Google Gears</a> and the <a href="http://www.w3.org/html/wg/html5/#sql"
>HTML 5 Spec</a> includes in-browser database APIs, so I believe SQL
Injection will become increasingly common in web applications.</p>

<p>XSS, Shell/SQL/Script/External-Entity Injection, etc. are all serious
security problems, but they all work because of essentially the same
problem &mdash; <i>programs that compose portions of another language
by concatenating strings can be easily fooled</i>.  Below is an
example of a SQL Injection vulnerability:

<blockquote><pre class=prettyprint>
query = "SELECT x, y, z FROM Table WHERE id='" + id + "'"
</pre></blockquote>

<p>If a malicious user can cause <code>id</code> to be <code>"';
DELETE FROM Table WHERE '' = '"</code>, then you'd better hope you
have good backups.  And there are many ways <code>id</code> could be
manipulated &mdash; the user can enter strange inputs in an online
form, manipulate CGI parameters, send crafted inputs to an SMS robot,
or exploit any of the myriad of ways that information gets into a
computer system.  The results can be pretty catastrophic &mdash;
they can be used to steal information from databases, insert false
records, steal accounts and money, and ruin peoples' and companies'
reputations.

<p>Languages tend to distinguish a string from a core piece of the
program by using <i>escaping</i> conventions.  In the SQL example
above, id could be rendered safe by converting <code>'</code>s to
<code>\'</code>s, and any <code>\</code> to <code>\\</code>.  And the
programmer could use a function to do that conversion, but that
approach is error prone, and requires the programmer to know a lot
about the language.  For HTML and XML, the programmer has to
consistently correctly choose between at least 4 different escaping
schemes:

<ul>
<li><code>&lt;[!CDATA[&hellip;]]&gt;</code> sections
<li>RCDATA content of <code>&lt;title&gt;</code> and
   <code>&lt;textarea&gt;</code> elements
<li>CDATA content of <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>,
   <code>&lt;xmp&gt;</code> elements
<li>PCDATA content in an html body
<li>attribute content
</ul>

<p>And frequently, there is more than one type of escaping.  If
composing a URL

<blockquote><pre class=prettyprint>
&lt;a href="$page?$a=$b&$c=$d"&gt;
</pre></blockquote>

the programmer has to URI-encode the parameters and page, and then
encode the whole URL as an HTML attribute, so that <code>$c</code> will
be interpreted correctly even if it happens to be <code>gt</code>.

<p>So when composing the usual soup of HTML, CSS, Javascript, and URLs
you have to contend with a viper's nest of subtly different escaping
schemes which have to be applied in the correct order.  And these
escaping schemes are not simple.  Libraries can provide the escaping
functions but they cannot help the programmer decide which escaping
convention is appropriate when.</p>

<p><i>Any API that requires the developer to know as much as the
implementor does not solve any problems.</i> Since choosing the
appropriate escaping function requires the developer to be a language
expert, simply providing libraries of escaping functions will not
address injection as a class of vulnerabilities.


<h2>Alternatives</h2>
<h3>Library specific templating</h3>

<p>Some library writers write <i>template libraries</i> to provide a
safe alternative.  The SQL example above could be rewritten safely in
JDBC as

<blockquote><pre class=prettyprint>
db.execute("SELECT x, y, z FROM Table WHERE id='?'", id)
</pre></blockquote>

<p>This solves the early-binding problem, by forcing binding to occur
where control leaves the programmers code, and enters the SQL
library's code.

<p>But thus far, none of these library-specific schemes have
completely displaced string interpolation, even in their specific
domain, and they tend to suffer from a few common flaws:

<p>First, by forcing binding to occur in a specific place, they break
<a href="http://en.wikipedia.org/wiki/Functional_decomposition"
><i>functional decomposition</i></a>.  Functional decomposition is,
simply put, a way of breaking large problems into smaller ones by
decomposing them into functions.  So in the SQL example, I might
decompose the problem into two subproblems : one to specify the table
and columns, and one to specify which rows I need:

<blockquote><pre class=prettyprint>
sub makeQuery() {
  my $columnsToFetch = chooseColumns();
  my $rowsToFetch = chooseRows();
  return "SELECT $columnsToFetch WHERE $rowsToFetch";
}

sub $columnsToFetch() { return "x, y, z FROM Table"; }
sub $rowsToFetch() { return "id='$id'";
</pre></blockquote>

<p>Functional decomposition only works if a piece of a program can be
replaced by a function call that does the same thing.  <i>APIs that
break functional decomposition suck, and will not scale to large
applications.</i>

<p>Second, library specific solutions are library specific.  A
developer who learns JDBC's <code>?</code> syntax cannot transfer
that knowledge to deal with translated message strings that use
<code>%1</code> style placeholders.

<p>Third, library specific tend to allow no exceptions to the rule,
and so force programmers to work around the system.  <i>Never, ever,
force your developers to work around your security checks because your
system does not allow them to do what they need to do.</i>  JDBC, for
example, does not handle the following common situation well

<blockquote><pre class=prettyprint>
"SELECT x, y, z FROM Table WHERE id IN ($set_of_ids)"
</pre></blockquote>

<p>If a programmer wants to specify multiple ids, they are out of
luck.  The system is incomplete, and so the programmer falls back on
&ndash; string interpolation or outright hackery.

<p>Finally, library specific solutions often use positional
parameters.  Positional parameters don't scale to large or complicated
templates.  The following example might have started off nice and small,
but as code has been added over the years (where 1 year ~ 1
caffeine-fueled weekend before launch) it has grown unmaintainable

<blockquote><pre class=prettyprint>
print 'I met a ? in the ? who had a ? full of ?.  He said'
      ' "Hello, ?, How are you today\?"  "Fine," I replied'
      ' "but I can't seem to find my ?."  "Hmm," he said.'
      '  "I Can\'t help you with that."  "How about a ? to'
      ' make you feel ?\?"',
      (profession, landmark, container, species_of_monkey,
       proper_name, common_household_item,
       'string that used to be tied to a red balloon',
       state_of_mind);
</pre></blockquote>

<p>If you found yourself looking back and forth to make sense of that,
then you know why positional parameters simply don't scale &mdash;
they require the programmer to keep O(n) things in their limited
brains.  String interpolation solves this by putting the expressions
in-line, so that each part of the string interpolation has meaning in
isolation.


<h3>Full-blown language templating</h3>

<p>A language template is a whole language, complete with its own version of
<code>if-else</code> and <code>for</code>, and stored in files separate from
the rest of the code.  For example, JSP is a templating language frequently
used with Java programs.  JSPs have their own looping constructs for iterating
over elements of a list, and JSP code is stored in <code>.jsp</code> files
instead of being near the java code that invokes it.

<p>Full blown templating languages are the right tool for many problems, but
they still can't compete with string interpolation on several fronts.

<p>First, full blown templating languages, with a few exceptions, do
next to nothing to solve escaping problems.  XSL does quite well on
this front with HTML (but has no support for other content types); but
JSP and PHP, which are two of the most popular means of generating
dynamic HTML; do not escape by default &mdash; they push the
responsibility onto the programmer to understand the myriad escaping
conventions and to choose the right one consistently and correctly.

<p>Second, templating languages tend to introduce a lot of <a
href="http://en.wikipedia.org/wiki/Boilerplate_(text)#Boilerplate_code"
>boilerplate</a>.
There's a certain amount of structure that always has to be there.
For example, in the below XSL example, all the grey text is
inconsequential to the actual functioning of the template and serves
only to hide the one salient (bold) bit.

<blockquote><pre>
<span style="color:#888"
>&lt;?xml version="1.0" standalone="no" encoding="UTF-8"?&gt;
&lt;!DOCTYPE xsl:stylesheet [
  &lt;!ENTITY % xhtml PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
  %xhtml;
]&gt;
&lt;xsl:stylesheet
    version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:text&gt;</span
     ><b>Hello World</b><span style="color:#888">&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</span></pre></blockquote>

<p>Third, templating languages don't make simple things simple.  If I
want to make a piece of text bold, I would much prefer to write
<code>"<b>$text</b>"</code> next to where I need it than to write and
comment a separate multi-dozen-line file to hold a template.


<h3>DOM manipulation</h3>

<p>DOM manipulation is familiar to many Javascript hackers:

<blockquote><pre class=prettyprint>
var myBoldTag = document.createElement('B');
myBoldTag.appendChild(document.createText(text));
</pre></blockquote>

<p>This is more verbose than the <code>"<b>$text</b>"</code>, but it
is inline and is safe.

<p>It's an excellent choice in many circumstances, but it is much
slower than injecting markup into <code>innerHTML</code>.  According
to <a href="http://www.quirksmode.org/dom/innerhtml.html" >Peter-Paul
Koch</a> of <tt>quirksmode.org</tt>, DOM manipulation takes 30 times
as long as <code>innerHTML</code> on IE 6.0, the most commonly used browser.



<h3>Tainting</h3>

<p><a
href="http://www.oreillynet.com/onlamp/blog/2006/11/perls_taint_mode_to_the_rescue.html"
>Tainting</a> attempts to avoid security breaches by marking strings
that come from untrusted sources, such as CGI parameters, in a way
that sensitive operations can check.  When strings are concatenated,
the result is tainted if any of the inputs were tainted.  A SQL
library can then check whether the query string is tainted and refuse
to execute it.

<p>Tainting mitigates some security problems but does not address
correctness &mdash; it may make it impossible for an attacker to tweak
a CGI parameter to cause a SQL injection attack.  It also does not
eliminate security problems because tainted inputs can be "laundered."
E.g., if your code looks like:

<blockquote><pre class=prettyprint>
"INSERT INTO Table VALUES ('<b>$name</b>')"
# Result is tainted because $name is tainted
</pre></blockquote>

then a programmer might reasonably rewrite it as

<blockquote><pre class=prettyprint>
"INSERT INTO Table VALUES ('<b>${sql_escape(name)}</b>')"
# sql_escape removes the tainting
</pre></blockquote>

<p>Now, the SQL is correct and safe, but a tainted input is in the
database.  If another page retrieves that from the database and
displays it, then you have a Script Injection vulnerability.  Tainting
does not encode the "type" of the string (E.g.,
<code>text/plain</code> vs <code>text/html</code>) so does not, by
itself, contain enough information to provide safety and correctness,
and the taint is not serialized with the string in the database, so
can be effectively laundered.

<blockquote><pre class=prettyprint>
name = getUserInput('name');  // Pretend getUserInput returns a tainted value.
name = sql_escape(name);  // Now name is untainted
execute("INSERT INTO Table (name) VALUES ('<b>$name</b>'");
</pre></blockquote>

<p>Now the value is in the database.  <code>name</code> is not
tainted, but it's not safe to inject it into <code>innerHTML</code>
since SQL's escaping conventions are very different from HTML's.

<blockquote><pre class=prettyprint>
names = query("SELECT name FROM Table");
var stringBuffer = [];
for (var i = 0; i < names.length; ++i) {
  stringBuffer.push('&lt;tr&gt;', '&lt;td&gt;', names[i]);
}
div.innerHTML = '&lt;table&gt;' + stringBuffer.join('') + '&lt;\/table&gt;';
</pre></blockquote>

<p>Regardless of whether the names are tainted, they're unsafe to use
in innerHTML.  Maybe this distinction between HTML and SQL seems
irrelevant to web applications, but web applications already combine
three languages, CSS/JS/HTML, each with different escaping
conventions.


<h3>Quasi-Literals</h3>

<p>The E-language, and a few others, provide "<a
href="http://www.skyhunter.com/marcs/ewalnut.html#SEC15"
>quasi-literals</a>" which are used to produce and manipulate <a
href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract
syntax trees</a> (AST), and to convert them back to strings, in a way
that makes the fact that ASTs are being manipulated transparent to the
developer.</p>

<p>An AST for

<blockquote><pre class=prettyprint>
&lt;a href="http://foo.com/?bar=$baz"&gt;
</pre></blockquote>

might look like

<blockquote><pre>
Element : a
  Attribute : href
    Value
      Url
        Protocol : http
        Authority
          Domain : foo.com
        Path : /
        Query
          Pair
            Key : bar
            Value
              QuasiLiteralReference baz
</pre></blockquote>

<p>The QuasiReferences can be evaluated to produce a new parse tree
which can then be rendered to a string.  The renderer has enough
information to maintain a stack of escaping conventions to apply, and
so can guarantee that it only produces well-formed output.</p>

<p>QuasiLiterals are a very elegant solution to many problems, but I
find quasi-literals poorly suited to Javascript because they require
generation, at runtime, of an abstract syntax tree, and object
creation is expensive in the most frequently used Javascript
interpreters.

<p>Quasi-literals are also poorly suited to HTML because HTML's tags
do not form a tree structure &mdash; formatting tags mark ranges of
text and do not need to nest, and all the input elements inside a form
are grouped together, so it is not unusual to see a
<code>&lt;/form&gt;</code> tag at a different nesting level from the
open <code>&lt;form&gt;</code> tag.  For example, the following HTML,
which is valid according to the HTML 5 draft,

<blockquote><pre class=prettyprint>
&lt;b&gt;A &lt;span style="color:blue"&gt;B&lt;/b&gt; C&lt;/span&gt;
</pre></blockquote>

is parsed to the same DOM Tree as the HTML below:

<blockquote><pre class=prettyprint>
&lt;b&gt;A &lt;span style="color:blue"&gt;B&lt;/span&gt;&lt;/b&gt;&lt;span style="color:blue"&gt; C&lt;/span&gt;
</pre></blockquote>

<p>Implementing quasi-literals for HTML in Javascript would require
building a full HTML parser, which the browser already has, just to do
inference that can be done purely at the lexical level.  The resulting
implementation would be large and slow given the current state of
Javascript interpreters.


<h2>Goals</h2>

<ul>
<li>An API as simple and expressive as string interpolation
  that is intuitive to developers familiar with Perl, PHP, or Ruby.
<li>Without the security or correctness problems, assuming non-malicious
  developers.
  <blockquote><small>
  If the exemptions defined below are not used, then a string interpolation
  should produce the same tokenization for the text between substitutions
  regardless of the values substituted.
  </small></blockquote>
<li>Without shifting the burden onto developers.
  <blockquote><small>
  Developers should not need to understand which escaping conventions are
  appropriate when.
  </small></blockquote>
<li>With minimal boilerplate.
<li>That extends to multiple domains.
  <blockquote><small>
  String interpolations are often used as a poor man's domain specific
  language.  The same scheme should allow for at least SQL query generation,
  HTML and XML generation, URI composition, and shell command composition.
  Anecdotally, these domains seem to cover the majority of injection attacks.
  </small></blockquote>
<li>That allows easily audited exemptions.
  <blockquote><small>
  Developers should never need to work around the system.  If a developer
  knows a priori that a string is safe in context, then they should be
  able to exempt it from escaping conventions.  These exemptions should
  be easy to find with <tt>grep</tt> and other code searching tools.
  </small></blockquote>
<li>Allow content-type markers, so that we can distinguish plain text,
  from known safe HTML.
  <blockquote><small>
  Content-type marking uses the runtime type system to convey
  information about the content of a string.  A DHTML rich-text editor
  control might return a string like object encapsulating known-safe
  HTML, <code class=prettyprint>new HtmlSnippet(content)</code>,
  instead of just returning a string.
  <br>
  This also addresses the problems identified when discussing tainting by
  distinguishing a string that is safe to inject unescaped into HTML from
  one that is safe to inject into SQL unescaped.
  </small></blockquote>
<li>That performs on par with string concatenation.  Should be at most
  <code>O(length_of_output + number_of_substitutions)</code>.
<li>That supports text localization without imposing a cost on
  interpolations that don't require localization.
  <blockquote><small>
  If a string interpolation includes human language text visible to the
  end-user, the application needs to be able to replace messages with
  messages in another language, and substitutions might move or be
  reordered within a message.
  </small></blockquote>
<li>Provides a clear migration path from existing code.
  <blockquote><small>
  Libraries should be able to operate in an unsafe mode where they issue
  warnings if the input is not a string interpolation, to help developers
  find string concatenation and replace it with string interpolation.
  </small></blockquote>
<li>Is amenable to source-to-source translation to extend the threat
  scenario to deal with malicious developers.
</ul>


<h2>Non-Goals</h2>

<ul>
<li>Feature parity with full blown templating languages.
   Specifically, conditional or looping constructs.
<li>Content sanitization.
<li>Provide an API for parse tree manipulation.
</ul>


<h2>Design &amp; Implementation</h2>

<p>The first thing we need to do is distinguish literal text from substituted
values.  Since our definition of security is to "ensure the same tokenization of
literal text regardless of substitution values", we need to identify literals
and substitutions, and once we've done that, we can examine literals to figure
out how to escape substitutions.</p>

<blockquote>
<table cols=5 class=spreadsheet>
<tr>
<td style=text-align:left>Original Interpolation:</td>
<td colspan=4><code class=prettyprint
 >"SELECT * FROM Table WHERE name='$name' AND modified > ${new Date(d)}"</code>
<tr><td><td colspan=4 style="font-size: 200%">&darr;</td>
<tr>
<td style=text-align:left>Split around substitutions:</td>
<td>Literal
  <br><code class=prettyprint>"SELECT * FROM TABLE WHERE name="</code></td>
<td>Substitution<br><code class=prettyprint>name</code></td>
<td>Literal<br><code class=prettyprint>"' AND modified > "</code></td>
<td>Substitution<br><code class=prettyprint>new Date(d)</code></td>
<tr><td><td colspan=4 style="font-size: 200%">&darr;</td>
<tr>
<td style=text-align:left>JS w/out Syntactic Sugar:</td>
<td colspan=4><code class=prettyprint>new StringInterpolation(["SELECT * FROM TABLE WHERE name='", name, "' AND modified > ", new Date(d)])</td>
<tr><td><td colspan=4 style="font-size: 200%">&darr;</td>
<tr>
<td style=text-align:left>With substitutions escaped:</td>
<td colspan=4><code class=prettyprint>"SELECT * FROM Table WHERE name='<b>O\'Reilly</b>' AND modified > <b>'2007-12-31 12:30:00'"</b></code></td>
</table>
</blockquote>

<p>We split the interpolation into literals and substitutions so that the SQL
library then has enough information to figure out how to escape
<code class=prettyprint>name</code> and
<code class=prettyprint>new Date(d)</code>.  We bundle the parts together in
a <code>StringInterpolation</code> object which the SQL library can manipulate.


<h3>Mixing in some Syntactic Sugar &mdash; Macro Expansion in Javascript</h3>

<p>Now that we have a <code>StringInterpolation</code> object, we need
to figure out how to add a bit of syntactic sugar to allow developers
to produce a <code>StringInterpolation</code> instance by writing
something like <code class=prettyprint>"Hello
$name_of_planet!"</code>.

<p>In many languages, we could write a macro to convert from
<code class=prettyprint>MY_MACRO("Hello $name_of_planet!")</code> to
<code class=prettyprint
>new StringInterpolation(['Hello ', name_of_planet, '!'])</code>,
but Javascript has no built-in macro system.

<p>Luckily, it does have an <code>eval</code> which resolves
references in the calling scope: <code class=prettyprint>function ()
{ var x = 4; return eval('x'); }</code> does return the number 4.  We
can use this odd property to bolt macro-expansion onto Javascript.

<blockquote>
<table class=spreadsheet cols=2>
<tr>
<td><td><code class=prettyprint>eval(MY_MACRO("Hello $name_of_planet!"))</code></td>
<tr>
<td style=text-align:left>MY_MACRO returns a string of JS code
<td style=font-size:200%>&darr;</td>
<tr>
<td><td><code class=prettyprint>eval('new StringInterpolation(["Hello ", name_of_planet, "!"])')</code></td>
<tr>
<td style=text-align:left>Which eval effectively inlines
<td style=font-size:200%>&darr;</td>
<tr>
<td><td><code class=prettyprint>new StringInterpolation(["Hello ", name_of_planet, "!"])</code></td>
</table>
</blockquote>

<p>So we can use <code>eval</code> to do macro expansion in
Javascript.  I show below how this can be made nicer syntactically, so
that <code>eval</code> need not be explicitly part of the API, and how
to <a href="#optimizer">speed this up</a> by expanding macros early.
But first, let's nail down the API.

<h3>API</h3>
<p>Let's come up with some examples of what we want to do.  If we want
it to run in a language without string-interpolation built-in, we need
some way of building a string interpolation using existing language
constructs such as function calls and string literals.  Let's call
these open templates and use the following syntax.</p>

<blockquote><pre class=prettyprint>
sql = open(Template("SELECT * FROM Table WHERE id=<b>$id</b>"));
url = open(Template("http://<b>$myDomain</b>/path?q=<b>$paramValue</b>"));
html = open(Template('&lt;div style="color: #<b>$fg</b>">$name&lt;/div&gt;'));
// where $id, $paramValue, etc. are bound to variables in the local
// scope at the time open(Template(&hellip;)) is invoked.

// Ruby's embedded expressions are popular, so let's define an alternative
// to the $ followed by a variable name syntax, like ruby
html = open(Template(
    '&lt;tr>&lt;td><b>${cells[0]}</b>&lt;td><b>${cells[1]}</b>&lt;/tr>'));
// where the expression inside the ${&hellip;} is an expression in the
// surrounding language, with balanced curly-brackets.  References evaluate
// in the local scope, and exceptions propagate out of the interpolation.

// To handle text L10N, we'll allow a run of text to be annotated.
// A parser can find all string interpolations and extract messages.
html = open(Template(
    '&lt;p&gt;<i>${{{msg="Greeting":</i>Hi <i>${{{ph="User":</i
    ><b>$user</b><i>}}}</i>,'
    + ' how are you today?<i>}}}</i>&lt;/p&gt;'));
// where 'msg' brackets a message, and 'ph' identifies a placeholder
// and tells a translator what to expect.
// ${{{&hellip;}}} blocks contain literal strings and they nest,
// and ${&hellip;} blocks contain code and don't nest.
</pre></blockquote>

<p>The <code>open(Template(&hellip;))</code> syntax identifies a string
interpolation, but how do we know how to interpret substitutions?
We could let the user specify the "type" of the interpolation, a la

<blockquote><pre class=prettyprint>
sql = sql(Template("SELECT * FROM Table WHERE id=<b>$id</b>"));
url = url(Template("http://<b>$myDomain</b>/path?q=<b>${params.q}</b>"));
html = html(Template('&lt;div style="color: #<b>$fg</b>">$name&lt;/div&gt;'));
</pre></blockquote>

<p>But that expands the size of the API, and doesn't give us enough
information.  Consider the HTML example above.  If that content is
inserted into a <code>&lt;title&gt;</code> or
<code>&lt;textarea&gt;</code> tag, then the angle brackets should be
interpreted literally, and if it were inserted into a
<code>&lt;style&gt;</code> tag, then the content should be interpreted
as CSS, so that scheme doesn't give us enough information to make
correct decisions.  We could require more specific information, but
that would require the developer to know a lot about the language,
commit in advance to how the interpolation is going to be used, and,
for safety's sake, the code that injects into <code>innerHTML</code>
would still need to check that it's appropriate in context.

<p>Finally, we want to allow an interpolation to be composed from
smaller parts:

<blockquote><pre class=prettyprint>
var tableHtml = open(Template("&lt;table"));
if (data.length) {
  tableHtml.append(open(Template(" cols=${data[0].length}")));
}
tableHtml = tableHtml.append(open(Template("&gt;")));
for (var j = 0; j < data.length; ++j) {
  var row = data[j];
  tableHtml.append(open(Template("&lt;tr&gt;"));
  for (var i = 0; i < row.length; ++i) {
    tableHtml.append(open(Template("&lt;td&gt;${row[i]}")));
  }
}
tableHtml.append(open(Template("&lt;/table&gt;")));
</pre></blockquote>

<p>and if we require the developer to supply fine grained context at
every step, then they need to know the HTML standard in detail, and
get it correct at every step.</p>


<h3>Implementing Late Binding String Interpolation</h3>

<p>Let's take advantage of late binding by letting the library that
uses the string value supply the context and the knowledge about how
to determine which escaping scheme to use for each substitution.  When
<code>open(Template(&hellip;))</code> is called, all we have is a
series of literal pieces of text, interspersed with substitution
expressions.  Since the substitutions need to be evaluated in local
scope, they need to be evaluated immediately, so the URL example above

<blockquote><pre class=prettyprint>
url = open(Template("http://<b>$myDomain</b>/path?q=<b>${params.q}</b>"));
</pre></blockquote>

yields

<table style=margin-left:2em>
<tr>
<td>Literal:
<td><code class=prettyprint>"http://"</code>
<tr>
<td>Substitution:&nbsp;
<td><code>myDomain</code>
<tr>
<td>Literal:
<td><code class=prettyprint>"/path?q="</code>
<tr>
<td>Substitution:&nbsp;
<td><code>params.q</code>
</table>

so we have a string-like object that encapsulates an array of alternating
literal and dynamic bits.  In Javascript:

<blockquote><pre class=prettyprint>
/**
 * A string like object that encapsulates a string interpolation's template and
 * substitutions, and provides a mechanism by which substitutions can be
 * re-escaped using information available at the strings final output point.
 *
 * @param {Array} args an array whose even elements are literal strings, and
 *   whose odd parts are substitutions.
 * @constructor
 */
function StringInterpolation(args) {
  this.args = args.slice(0);
}
</blockquote></pre>

and let's make it behave like a string when viewed in a debugger, or
put into a sorted collection, or used as a key in a hashmap:

<blockquote><pre class=prettyprint>
// Next, let's make it string-like.  If used in a string context, it should
// coerce to a string for debugging.
StringInterpolation.prototype.toString = function () {
  return this.args.join('');
};
StringInterpolation.prototype.valueOf = function (type) {
  if (type === 'string') { return this.toString(); }
  if (type === 'boolean') { return this.toString() !== ''; }
  return this;
};
</blockquote></pre>

<p>Which suggests a way to bolt string interpolation onto Javascript.
If the <code>open</code> function behaves like <code>eval</code>, then
we can easily evaluate the substitutions in the local scope, which
would be really convenient if <code>Template</code> returns Javascript
that creates a <code>StringInterpolation</code>:

<blockquote><pre class=prettyprint>
// open is eval, so that we can evaluate substitutions in the local scope.
var open = eval;

// To make sure that
(Template("http://<b>$myDomain</b>/path?q=<b>${params.q}</b>") ===
 'new StringInterpolation(["http://", <b>myDomain</b>, "/path?q=", <b>params.q</b>])'

// we can define Template as
function Template(interpolation) {
  var parts = interpSplitStringIntoParts(interpolation);
  return makeStringInterpolationConstructor(parts);
}

function interpSplitStringIntoParts(interpolation) {
  // Generate an array where even elements are literals and odd ones are
  // substitutions.  This may involve putting empty literals in between
  // contiguous substitutions.
  &hellip;
}

function makeStringInterpolationConstructor(parts) {
  // Make a fake String Interpolation constructor, so that interp (aka eval)
  // will evaluate it in the context of the local variables it appears with.
  var javascript = ['new StringInterpolation(['];
  for (var i = 0, n = parts.length; i < n; ++i) {
    if (i) { javascript.push(','); }
    if (i & 1) {
      javascript.push('(', parts[i], ')');
    } else {
      javascript.push(javascriptStringLiteral(parts[i]));
    }
  }
  javascript.push('])');
  return javascript.join('');
}
</pre></blockquote>

<p>But how will a library developer turn the interpolation into a
string.  There's a couple cases we need to consider.  First, to
support functional decomposition string interpolations need to nest.
So string interpolation processing will need to recurse if a
substitution value is a string interpolation.  This recursion could be
tricky, and we still need to figure out how to do exemptions, so we
shouldn't rely on all library implementors to do it correctly.  A
library writer needs to know the following:
<ul>
  <li>The context in which the whole string will be used.
  <li>The context in which each substitution appears.
  <li>How to escape a substitution in context.
</ul>

<p>The last is a bit complicated since the escaping might change the
context.  In <code class=prettyprint>&lt;a href=<b>$url</b>&gt;</code>
we'd like to be able to surround <code>$url</code> with quotes which
would be different from <code class=prettyprint>&lt;a
href="http://<b>$domain</b>/"&gt;</code> where <code>$domain</code>
is already in a quoted string.  So as a library writer handles each
literal or substitution in turn, it needs to keep track of context.
The context will likely correspond to a non-terminal on the left hand
side of a context-free grammar rule.

<p>So let's try to let the library writer handle computing the context
and escaping substitutions, and abstract away the problem of iterating
over pieces and recursing into substitutions that are interpolations.
Let's define one operation to keep track of the context for a literal
chunk, and one to process a substitution.  The literal handler needs
to take the context that the start of the literal appears in, and
returns the context at the end of the string.  The substitution
handler needs to take a context, perform escaping, and return the
context at the end.  Let's add a method to our
<code>StringInterpolation</code> class that takes the literal handler
(which we'll call <code>contextScanner</code>) and the substitution
handler (called <code>escaper</code>):

<blockquote><pre class=prettyprint>
/**
 * Perform custom interpolation.
 * @param {Function} contextScanner takes (string, context, outputBuffer) and
 *   returns an updated context.  The type of context is up to the caller.
 * @param {Function} escaper takes (substitution, context, outputBuffer),
 *   appends an appropriate string-form of substitution onto outputBuffer,
 *   and returns the context.
 *   Substitution may be of any type.  Zero or more strings may be pushed onto
 *   outputBuffer which will be joined on the empty string to produce the
 *   interpolated string.
 * @param {Array.&lt;string>} outputBuffer the buffer that output is written to.
 *   An Array that can be joined on the empty string to produce the
 *   interpolated string.
 * @return the context.  This is returned so that the caller can examine it and
 *   rror out if it is not a valid ending state.
 *   E.g., an XML templater could throw an exception if tags weren't closed.
 */
StringInterpolation.prototype.interpolate = function (
    contextScanner, escaper, initialContext, outputBuffer) {
  var context = initialContext;
  for (var i = 0, n = this.args.length; i < n; ++i) {
    var arg = this.args[i];
    if (i & 1) {  // args is a substitution
      if (arg instanceof StringInterpolation) {
        // Recurse.  This allows, e.g., production of a WHERE clause as one
        // interpolation which can then be substituted into a SELECT stmt.
        context = arg.interpolate(
            contextScanner, escaper, context, outputBuffer);
      } else {
        context = escaper(arg, context, outputBuffer);
      }
    } else {
      outputBuffer.push(arg);
      context = contextScanner(arg, context, outputBuffer);
    }
  }
  return context;
};
</pre></blockquote>

<p>We don't specify a type for <code>initialContext</code> since we
never need to analyze it.  The library writer can give us a primitive
or object, and we'll pass it back and forth between the
<code>escaper</code> and <code>contextScanner</code> that they supply.
Then when the the whole interpolation is done, the library writer can
inspect the context and determine whether it's in a valid end
state.</p>


<h3>Implementing Auditable Exemptions</h3>

<p>The whole point of auditable exemptions is to allow a developer to
substitute a value that they know is suitable in context without
working around the system.  The use of this feature breaks security,
but I believe it's necessary because letting developers intentionally
do unsafe things within the system is better than the alternatives:
developers hastily and incorrectly reimplementing parts of the system
from scratch, or unintentionally doing unsafe things by reverting to
simple string concatenation.

<p>There are a few ways we could let a user specify an exemption:
<blockquote><pre class=prettyprint>
// A special raw flag that appears in the interpolation.
html = open(Template("<div>$raw{foo}</div>");

// A special type that specifies the context in which something is meant to
// appear.
safeFoo = new Html("foo");
html = open(Template("<div>$safeFoo</div>");

// A special type that does not specify context.
rawFoo = new RawStringSubstitution("foo");
html = open(Template("<div>$rawFoo</div>");
</pre></blockquote>

<p>The first option violates the principle of late binding, and
decomposability.  Maybe sometimes <code>foo</code> will come from a
source that is known to be good, and sometimes it won't and needs to
be escaped.

<p>The second option is a great idea, and solves the problems
identified with tainting above by allowing a knowledgeable developer
to assert the type.  A library writer in their <code>escaper</code>
could check the type and elect not to escape certain classes of
substitution values, so this requires no work from us.

<p>But the second doesn't work well for developers who don't know
details of the language being generated, it puts a burden on every
library writers to meet our goal of auditable exemptions, it violates
our goal of providing primitives that work in many domains, and there
is no single string that we can search for to audit all exemptions.

<p>I like the second approach and library writers can support it, but
I think we still need something like the third option which is not
language specific.

<p>Since we implemented the <code>interpolate</code> method on
<code>StringInterpolation</code>, and the <code>interpolate</code>
recurses when it sees a nested <code>StringInterpolation</code>
we can implement <code>RawStringSubstitution</code> a subclass.

<blockquote><pre class=prettyprint>
/**
 * A string interpolation that always outputs the same content.  This allows
 * exemptions to the normal escaping scheme, so should be used sparingly.
 * To audit all uses, run
 *
 * $ egrep -nH '\bRawStringSubstitution\b' &lt;file0.js&gt; &hellip;
 *
 * @param {string} s raw text that should not be escaped.
 */
function RawStringSubstitution(s) {
  this.s = String(s);
}
// Subclass StringInterpolation so that StringInterpolation.interpolate will
// delegate to this class when its used as a substitution value.
RawStringSubstitution.prototype = new StringInterpolation([]);
RawStringSubstitution.prototype.constructor = RawStringSubstitution;
// Now override interpolate to not invoke the escaper.
RawStringSubstitution.prototype.interpolate = function (
    contextScanner, escaper, initialContext, outputBuffer) {
  outputBuffer.push(this.s);
  return initialContext;
};
RawStringSubstitution.prototype.toString = function () { return this.s; };
</pre></blockquote>


<h2>String Interpolation Examples</h2>

<p>Now that we have an idea of what a string interpolation is, and how
context scanners give escapers information cooperate to produce safe
&amp; correct output, how do we design a useful escaper?  Let's
consider the different ways to escape a string.

<blockquote><pre class=prettyprint>
var ids = [1, 2, 3, 4];
var column = 'value';
var foo = 'foo';

open(Template("SELECT <b>$column</b> FROM Table WHERE id IN <b>$ids</b> AND foo LIKE <b>$foo</b>"))
    === "SELECT <b class=annotated title="If unquoted, we can choose a quoting convention based on the last keyword.">`value`</b> FROM Table WHERE id IN <b class=annotated title="IN has to be followed by a set">(1, 2, 3, 4)</b> AND foo LIKE <b class=annotated title="When in doubt, treat strings as literals">'foo'</b>"
</pre></blockquote>


<p>My friend, J0hn &lt;Q&gt; D'oe was named by his techie parents
during the middle of the internet boom, but despite his geeky
pedigree, he has frequent trouble with web forms.  Here's how an
application might use safe string interpolation to render a form that
works for J0hn:

<table border=1 cellpadding=4 cellspacing=0 cols=2>
<tr>
  <td align=center colspan=2>
    <code class=prettyprint>userName = "J0hn &lt;Q&gt; D'oe"</code>
  </td>
<tr>
  <td style="text-align: left"><pre>
&lt;a href="logout">
  &lt;img src="logout.png" title="Logout from <b>$userName's</b> account"&gt;
&lt;/a>

&lt;form onsubmit="
    if (!/\S/.test(this.elements.fullname.value)) {
      alert("<b>$userName</b>, please enter your full name");
      this.elements.fullname.focus();
      return false;
    }"&gt;

  &lt;input type=hidden name=userName value=<b>$userName</b>&gt;

  Welcome <b>$userName</b>,
  &lt;p&gt;
  Full Name: &lt;textarea name=fullname><b>$userName</b>&lt;/textarea&gt;
  &lt;p&gt;
  DOB: &hellip;
</pre></td>
  <td style="text-align: left"><pre
>&lt;a href="logout"&gt;
  &lt;img src="logout.png" title="Logout from <b class=annotated title="Don't quote since already in quoted attribute">J0hn &amp;lt;Q&amp;gt; D&amp;#39;oe</b>'s account"&gt;
&lt;/a&gt;

&lt;form onsubmit="
    if (!/\S/.test(this.elements.fullname.value)) {
      alert("<b class=annotated title="In Javascript string, so use backslashes instead of html entities">J0hn \74Q\76 D\47oe</b>, please enter your full name");
      this.elements.fullname.focus();
      return false;
    }"&gt;

  &lt;input type=hidden name=userName value=<b class=annotated title="Not in a quoted string, so add quotes">"J0hn &amp;lt;Q&amp;gt; D&amp;#39;oe"</b>&gt;

  Welcome <b class=annotated title="Escape &lt; and &gt; in HTML text">J0hn &amp;lt;Q&amp;gt; D'oe</b>,
  &lt;p&gt;
  Full Name: &lt;textarea name=fullname&gt;<b class=annotated title="No need to escape &lt; and &gt; in textarea, usually">J0hn &lt;Q&gt; D'oe</b>&lt;/textarea&gt;
  &lt;p&gt;
  DOB: &hellip;
</pre></td>
</table>

<p>Since we can differentiate attributes and elements whose content is
Javascript from those that contain plain text, we can substitute in
numeric, boolean, and null values literally to make it easy to compose
event handlers.



<h2>Implementing Context Scanners using State Machines</h2>

<p>Our implementation of <code>StringInterpolation.interpolate</code>
works on a single left to right scan, which meets our goals for
efficiency, <code>O(length_of_output + number_of_substitutions)</code>,
and it allows us to handle cases like the below without backtracking:

<blockquote><pre class=prettyprint>
// Output &lt;h1&gt;, &lt;h2&gt;, &hellip; as appropriate.
headerHtml = open(Template("&lt;h$n&gt;$sectionTitle&lt;/h$n&gt;"));
</pre></blockquote>

<p>Since we're working at the lexical level instead of manipulating
parse trees, most of the grammars we're going to deal with are <a
href="http://en.wikipedia.org/wiki/Formal_grammar#The_Chomsky_hierarchy"
>regular</a> and so can be implemented in terms of a FSM which
requires zero <a href=
"http://en.wikipedia.org/wiki/Lookahead#Lookahead_in_parsing"
>lookahead</a> and zero lookbehind, LA(0) &amp; LB(0).  But we'd like
to use the state variable as an input to the escaper to choose an
appropriate escaping convention, so we want to avoid the potentially
exponential number of states required by regular expressions, since it
makes the mapping from states to escaping conventions complicated.

<p>State machines are nice though since the entire state is
representable by an integer.  In many languages, object creation is
more expensive than computing primitives, and especially so in many
Javascript interpreters, so it'd be great if we could get the benefits
of a simple state representation without an exponential explosion of
states.

<p>Our <code>StringInterpolation.interpolate</code> function has
access to the output buffer &mdash; all the content written so far, so
we effectively have access to infinite lookbehind: LA(0) &amp;
LB(&#8734;).  This means that we can avoid the exponential explosion
in number of states, by keeping track of key pieces of data.

<p>In <code class=prettyprint>open(Template('&lt;<u>textarea</u
> <u>onchange</u>="alert(<b>$foo</b>)"&gt;'));</code>, we need to keep
track of the tag name and attribute names since the body of a
<code>textarea</code> tag has different escaping conventions for
content than other tags, and the content of the <code>onchange</code>
attribute is Javascript and so needs to layer html escaping
conventions on top of Javascript escaping conventions.

<p>To track the current tag name and attribute name as we walk over a
string of html is to place a bookmark when we see the beginning and
grab the value from the output buffer when we see the end.  Then, when
we see the beginning of the attribute value or the end of the tag, we
can choose a state from a limited set.

<p>So, ignoring html attributes, we might specify a state machine
for html as as:</p>
<blockquote><pre class=prettyprint>
# Specify a state that handles text nodes
pcdata:
  '&lt;'             : tag_start

# Once we've seen a &lt;, look for a tag name
tag_start:
# Treat alpha as matching any alphabetic character.
# The "record" below is a side effect of the transition that places a
# bookmark at the current location, so we can "store" the value into
# the variable tag_name.
  alpha           : tag_name, record(tag_name)
  '/'             : close_tag_start
# If we don't see something that starts a tag, reinterpret the character
# <u>a</u>s if we were in pcdata.  This can be done by copying states into this
# state.
  else            as pcdata

close_tag_start:
  alpha           : tag_name  # no need to record name for close tags
  else            : error("expected letter after &lt;/")

tag_name:
  alpha, num      : tag_name
  space, newline  : tag_body, store(tag_name, 'i')
  '&gt;'             as end_tag, store(tag_name, 'i')
  else            : error

&hellip;
</pre></blockquote>

and then when we need to decide what to do when we reach the end of a tag:

<blockquote><pre class=prettyprint>
def end_tag(tag_name):
  'xmp':  cdata
  'style': cdata_css, store(attrib_delim, '')
  'script': cdata_js, store(attrib_delim, '')
  'title': rcdata
  'textarea': rcdata
  'plaintext': plain_text
  else: pcdata
</pre></blockquote>

<p>which switches on the <tt>tag_name</tt> variable to decide how to
interpret the content following the tag.  The <a
href="http://www.w3.org/html/wg/html5/#parsing2">HTML5</a> <a
href="http://www.w3.org/html/wg/html5/#tokenisation">spec</a> explains
the distinctions between CDATA, PCDATA, and RCDATA.

<p>Now our HTML escaper can use a lookup table that maps states
(<tt>pcdata</tt>, <tt>tag_start</tt>, <tt>tag_name</tt>,
<tt>cdata</tt>, etc.) to escaping functions.  But our state has to
include bookmarks and variables, so how have we addressed the problem.
Since we have mappings like <tt>end_tag</tt> above that lists the
values of <tt>tag_name</tt>, we can inspect the state machine
specification to determine the set of all values we're interested in,
and make a table mapping those to integers, and bitpack the variable
state onto the end of the state machine state.  If we constrain ourselves
to keeping one open bookmark at a time, we can also bitpack the bookmark.


<h3>Memoizing Escaper Results to Improve Performance</h3>

<p>If we have a string interpolation in a tight loop, we'd like to
avoid recomputing context over and over again.

<p>Once we've figured out how to represent our state variable as a
primitive or immutable object, we can memoize a lot of the output of
our context scanners.  In the above example, our context scanner takes
a literal string, an input state, an output buffer, and produces an
output state.  In the frequent case where we're not recording a variable,
our output state is specified entirely by the literal string and the input
state.

<p>The below wraps a context scanner that doesn't require the output buffer
to memoize results.  The same scheme can be extended to our state machine
based context scanners if we can determine whether a state has a bookmark
or not.

<blockquote><pre class=prettyprint>
/**
 * Given a context scanner that takes immutable contexts, and that consistently
 * returns the same context for any (literalString, context) pair, cache results
 * to improve string interpolation performance.
 *
 * @param {Function} contextScanner a context scanner as specified in the
 *     StringInterpolation.interpolate method's API.
 * @return {Function} a contextScanner that is equivalent to the input if the
 *     conditions in this method's description hold.
 */
function memoizingContextScanner(contextScanner) {
  var cache = {};
  var size = 0;

  return function (literalString, context, outputBuffer) {
    // If context is a number it won't contain \0, so this is unambiguous.
    var cacheKey = literalString + '\0' + context;
    if (cacheKey in cache) {
      return cache[cacheKey];
    }
    // Flush the cache if it gets too large to bound memory consumption.
    if (++size === 100) {
      cache = {};
      size = 0;
    }
    return cache[cacheKey] = contextScanner(literalString, context, undefined);
  };
}
</pre></blockquote>

<p>I believe that the number of times a context scanner will end with a live
bookmark will be tiny in practice.  In the HTML scanner there are two cases
where it might happen:

<blockquote><pre class=prettyprint>
// When we have a substitution in the middle of a tag name.
open(Template("&lt;h<b>$n</b>&gt;"))

// Or a substitution in the middle of an attribute name.
open(Template("&lt;a on<b>$handlerName</b>=foo()&gt;"))
</pre></blockquote>


<h2>&micro;benchmarks &mdash; String Interpolation vs. String Concatenation</h2>
<p>I <a href="html/microbechmark.html">benchmarked</a> the Javascript
<code>open(Template(&hellip;))</code> <a href="html/fsm.txt">implementation</a>,
and when the string interpolation is statically optimized to remove
the eval call, it performs competitively with string concatenation.

<p>The optimized call to <code>open(Template(&hellip;))</code> is about
2 to 4 times as expensive as straight string concatenation, but is a fraction of
the cost of building the DOM using <code>appendChild</code>, so should be fast
enough for most applications.

<blockquote><dl>
<dt># rows</dt>
<dd>The number of table rows being generated</dd>
<dt>string +=</dt>
<dd>How long does it take to compose html using string concatenation?
    This is quick, but unsafe.</dd>
<dt>Array.join</dt>
<dd>How long does it take to compose the string using <code>Array.push</code>
    and <code>Array.join('')</code>?
    This is also quick, scales to large chunks of html on IE, but is unsafe.
    </dd>
<dt>open(Template(&hellip;))</dt>
<dd>How long does it take unoptimized <code>open(Template(&hellip;))</code>
    to compose html.
    This is safe, but is slow due to frequently calling eval.</dd>
<dt>open(Template(&hellip;)) 2</dt>
<dd>How long does it take optimized <code>open(Template(&hellip;))</code>
    to compose html.
    This is safe, and reasonably fast.  I optimized out the call to eval by
    rewriting <code>open(Template("foo $bar"))</code> with
    <code>new StringInterpolation(['foo ', (bar)])</code>.</dd>
<dt>DOM</dt>
<dd>How long does it take to compose a table using
    <code>document.createElement</code> and <code>Element.appendChild</code>?
    This is safe, and so probably the best comparison to
    <code>open(Template(&hellip;))</code> but is quite slow.</dd>
<dt>render time</dt>
<dd>How long does the browser take to parse, layout, and render the html
    generated by any of the first 4 methods?</dd>
</dl></blockquote>


<p>On Firefox on Linux:
<table cellspacing=4 cols=7 class=spreadsheet>
<tbody>
<tr>
  <th># rows</th>
  <th>string +=</th>
  <th>Array.join</th>
  <th>open(Template(&hellip;))</th>
  <th>open(Template(&hellip;)) 2</th>
  <th>DOM</th>
  <th>render time</th>
</tr>
<tr>
  <td>1000</td>
  <td>54 ms</td>
  <td>68 ms</td>
  <td>1043 ms</td>
  <td>204 ms</td>
  <td>508 ms</td>
  <td>586 ms</td>
</tr>
<tr>
  <td>5000</td>
  <td>267 ms</td>
  <td>332 ms</td>
  <td>5255 ms</td>
  <td>1159 ms</td>
  <td>2528 ms</td>
  <td>1458 ms</td>
</tr></tbody></table>

<p>On IE6 on Windows XP running under VMWare:
<table cellspacing=4 cols=7 class=spreadsheet>
<tbody>
<tr>
  <th># rows</th>
  <th>string +=</th>
  <th>Array.join</th>
  <th>open(Template(&hellip;))</th>
  <th>open(Template(&hellip;)) 2</th>
  <th>DOM</th>
  <th>render time</th>
</tr>
<tr>
  <td>1000</td>
  <td>141 ms</td>
  <td>156 ms</td>
  <td>1328 ms</td>
  <td>328 ms</td>
  <td>1782 ms</td>
  <td>281 ms</td>
</tr>
<tr>
  <td>5000</td>
  <td>1531 ms</td>
  <td>1297 ms</td>
  <td>12359 ms</td>
  <td>2969 ms</td>
  <td>25703 ms</td>
  <td>1594 ms</td>
</tr></tbody></table>


<h2>Migrating Existing Code</h2>

<p>Most Javascript heavy applications have quite a lot of code that
produces html that looks like that on the left below.  It can easily
be migrated piecemeal to use string interpolation by replacing the
yellow highlighted bits with calls to
<code>open(Template(&hellip;))</code> and <code>.append</code> as done
on the right.</p>

<blockquote>

<table border=1 cellpadding=4 cellspacing=0 cols=2>
<tr>
<td>
<pre class=prettyprint>
// Generate a select list like
//     &lt;select name=state&gt;
//       &lt;option value=AL&gt;Alabama&lt;/option&gt;
//       &hellip;
//     &lt;/select&gt;
var states = { AL: "Alabama", AK: "Alaska", AZ: "Arizona", &hellip; };
var abbreviations = [];
for (var k in states) { abbreviations.push(k); }
abbreviations.sort();

var selectListHtml = '&lt;select name=state&gt;';
for (var i = 0, n = states.length; i < n; ++i) {
  var abbrev = abbreviations[i];
  selectListHtml<span class=changed> += </span>'&lt;option value=<span class=changed>' + </span>abbrev<span class=changed> + '</span>&gt;<span class=changed>'</span>
      <span class=changed>+ </span>states[abbrev]<span class=changed> + '</span>&lt;/option&gt;';
}
selectListHtml<span class=changed> += </span>'&lt;/select&gt;';</pre></td>
<td>
<pre class=prettyprint>
// Generate a select list like
//     &lt;select name=state&gt;
//       &lt;option value=AL&gt;Alabama&lt;/option&gt;
//       &hellip;
//     &lt;/select&gt;
var states = { AL: "Alabama", AK: "Alaska", AZ: "Arizona", &hellip; };
var abbreviations = [];
for (var k in states) { abbreviations.push(k); }
abbreviations.sort();

var selectListHtml = <span class=changed>open(Template(</span>'&lt;select name=state&gt;'<span class=changed>))</span>;
for (var i = 0, n = states.length; i < n; ++i) {
  var abbrev = abbreviations[i];
  selectListHtml<span class=changed>.append(open(Template(</span>
      '&lt;option value=<span class=changed>$</span>abbrev&gt;<span class=changed>${</span>states[abbrev]<span class=changed>}</span>&lt;/option&gt;'<span class=changed>)))</span>;
}
selectListHtml<span class=changed>.append(open(Template(</span>'&lt;/select&gt;'<span class=changed>)))</span>;</pre></td>
</tr>
</table></blockquote>

<h2 id=optimizer>Benefiting from Source-to-Source translation</h2>

<p>We can bolt string interpolation onto a language that has an
<code>eval</code> operator that evaluates in local scope, but as the
benchmarks above show, this implementation comes at a significant
runtime cost.</p>

<p>The form below connects to a script that can be used to precompute
the <code>StringInterpolation</code> constructor so that
<code>eval</code> isn't called.

<script type="text/javascript" src="string-interpolation.js"></script>
<script type="text/javascript" src="tools/optimizer.js"></script>
<table border=1 cellpadding=4 cellspacing=0 cols=2>
<tr valign=top><td><textarea cols=80 rows=20 id=js_src_to_optimize>
var foo = open(Template("Interpolate ${this}!"));
</textarea>
<td><pre id=optimized_output>&nbsp;</pre></td>
</table>
<input type=button value="Optimize" onclick="
    var input = document.getElementById('js_src_to_optimize');
    var src = input.value;
    var result = document.getElementById('optimized_output');
    try {
      var optimizedSource = optimizeOpenTemplate(src);
      result.style.color = '#000';
      result.replaceChild(
          document.createTextNode(optimizedSource), result.firstChild);
    } catch (e) {
      result.replaceChild(
          document.createTextNode(String(e) + '\n' + (e.stack || '')),
          result.firstChild);
      result.style.color = '#f00';
      input.focus();
      input.select();
    }">
</body>
</html>
