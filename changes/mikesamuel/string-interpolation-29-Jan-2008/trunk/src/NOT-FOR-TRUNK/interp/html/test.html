<html>
<head>
<title>HTML State Machine</title>

<script src=fsm.js type=text/javascript></script>
<script src=../string-interpolation.js type=text/javascript></script>
<script src=html.js type=text/javascript></script>
<script type=text/javascript>
function assertTrue(var_args) {
  var msg, condition;
  switch (arguments.length) {
    case 1:
      condition = arguments[0];
      break;
    case 2:
      msg = arguments[0];
      condition  = arguments[1];
      break;
    default:
      throw new Error('assertTrue expects 1 or 2 arguments');
  }

  if (condition !== true) {
    throw new Error(msg || 'condition evaluated to a value other than true');
  }
}

function assertEquals(var_args) {
  var msg, a, b;
  switch (arguments.length) {
    case 2:
      a = arguments[0];
      b = arguments[1];
      break;
    case 3:
      msg = arguments[0];
      a = arguments[1];
      b = arguments[2];
      break;
  }

  if (!(a === b)) {
    throw new Error((msg ? msg + ': ' : '') + '`' + a + '` !== `' + b + '`');
  }
}

function assertState(htmlSnippetsAndEndStates) {
  assertTrue((htmlSnippetsAndEndStates.length % 2) === 0);

  var buf = [];
  var state = html.State.PCDATA;
  for (var i = 0; i < htmlSnippetsAndEndStates.length; i += 2) {
    var htmlSnippet = htmlSnippetsAndEndStates[i];
    var endState = htmlSnippetsAndEndStates[i + 1];
    assertEquals('string', typeof htmlSnippet);
    assertEquals('end state corresponding to `' + htmlSnippet + '`',
                 'number', typeof endState);

    buf.push(htmlSnippet);
    state = process(htmlSnippet, state, buf);
    
    assertTrue(
        'Expected state ' + (this.state_name ? state_name[endState] : '?')
        + '#' + endState + ' after snippet `' + htmlSnippet + '` but was '
        + (this.decodeState ? decodeState(state) : 'raw#' + state),
        getStateId(state) === endState);
  }
}
</script>

<script type=text/javascript>

function testHtmlParsing() {
  assertState(
      ['',             html.State.PCDATA,
       '<html',        html.State.TAG_NAME,
       '>',            html.State.PCDATA,
       '<title id="',  html.State.DQ_ATTRIB_VALUE,
       'foo">',        html.State.RCDATA,  // Title is not PCDATA
       'foo<b',        html.State.RCDATA_LT,  // Tags interpreted literally
       '></b>',        html.State.RCDATA,  // Mismatched close tag has no effect
       '</title>',     html.State.PCDATA,  // RCDATA closes on end title tag
       '<body',        html.State.TAG_NAME,
       ' ',            html.State.TAG_BODY,
       'bgcolor',      html.State.ATTRIB_NAME,
       '=',            html.State.TAG_AFTER_EQ,
       '\'',           html.State.SQ_ATTRIB_VALUE,
       'red\'',        html.State.TAG_BODY,
       ' onload=',     html.State.TAG_AFTER_EQ,
       '"',            html.State.DQ_JS,  // JS since the attrib is onclick
       'alert(',       html.State.DQ_JS,
       '\'how',        html.State.DQ_JS_SQ_STRING,  // Now we're in a string
       'dy \\\'',      html.State.DQ_JS_SQ_STRING,  // Escaped quote ignored
       'world\'',      html.State.DQ_JS,     // Unescaped quotes do
       ')"',           html.State.TAG_BODY,  // Close quotes end attribute
       '>',            html.State.PCDATA,
       'Bar',          html.State.PCDATA,
       '</body',       html.State.TAG_NAME,
       '></html>',     html.State.PCDATA]);
}

function testPcdataIsValidEndState() {
  assertTrue(isValidEndState(html.State.PCDATA));
}

function testScriptTagsContentAndEnd() {
  assertState(
      ['<script>"',     html.State.CDATA_JS_DQ_STRING,
       'foo<\/script>', html.State.PCDATA]);
}

function testScriptTagNamesCaseInsensitive() {
  assertState(
      ['<SCRIPT>"',     html.State.CDATA_JS_DQ_STRING,
       'foo<\/scrIpt>', html.State.PCDATA]);
}

function testWholeTagNameConsidered1() {
  assertState(
      ['<script>1<\/scrip-hah-fooled-you', html.State.CDATA_JS]);
}

function testWholeTagNameConsidered2() {
  assertState(
      ['<script>1<\/scriphah-fooled-you', html.State.CDATA_JS]);
}

function testEndTagCanBeEscaped() {
  assertState(
      ['<script>1 + "<\\\/scriphah-fooled-you\"', html.State.CDATA_JS]);
}

function testScriptTagClosesEvenIfUnclosedBlockComment() {
  assertState(
      ['<script>/*', html.State.CDATA_JS_BLOCK_COMMENT,
       '<\/script ', html.State.TAG_BODY]);
}

function testScriptTagNotClosedByPartialCloseTag() {
  assertState(
      ['<script>/*', html.State.CDATA_JS_BLOCK_COMMENT,
       '<\/scrip ',  html.State.CDATA_JS_BLOCK_COMMENT]);
}

function testCommentEndAfterPartialCloseTagClosesComment() {
  assertState(
      ['<script>/*', html.State.CDATA_JS_BLOCK_COMMENT,
       '<\/scrip*/', html.State.CDATA_JS]);
}

function testCommentDoubleStarSlashClosesBlockComment() {
  assertState(
      ['<script>/*', html.State.CDATA_JS_BLOCK_COMMENT,
       'foo **/',    html.State.CDATA_JS]);
}

function testScriptTagClosesEvenIfUnclosedLineComment() {
  assertState(
      ['<script>// ', html.State.CDATA_JS_LINE_COMMENT,
       '<\/script>',  html.State.PCDATA]);
}

function testLineCommentClosesNormallyInPresenceOfPartialCloseTag() {
  assertState(
      ['<script>// ', html.State.CDATA_JS_LINE_COMMENT,
       '<\/scri\n',   html.State.CDATA_JS]);
}

function testCloseTagsDontCloseAttributes() {
  assertState(
      ['<a',           html.State.TAG_NAME,
       ' ',            html.State.TAG_BODY,
       'onclick',      html.State.ATTRIB_NAME,
       '=',            html.State.TAG_AFTER_EQ,
       '"',            html.State.DQ_JS,
       '1<\/script /', html.State.DQ_JS_SLASH,
       ' > 2"',        html.State.TAG_BODY,
       '>',            html.State.PCDATA]);
}

function testHtmlEntitiesWorkInScriptAttributes() {
  assertState(
      ['<a onclick="', html.State.DQ_JS,
       '\'a\' + ',     html.State.DQ_JS,
       '&quOt;',       html.State.DQ_JS_DQ_STRING,
       'boo',          html.State.DQ_JS_DQ_STRING,
       '&#34;',        html.State.DQ_JS,
       ' + &#x22;a\\', html.State.DQ_JS_DQ_STRING_ESC,
       '"',            html.State.TAG_BODY,
       '>',            html.State.PCDATA]);
}

function testStyleAndTextAreaTreatedAsCdata() {
  assertState(
      ['<foo>',                           html.State.PCDATA,
       '<b>',                             html.State.PCDATA,
       '<span style=\'background: url("', html.State.SQ_CSS_DQ,
       'sprinkles.jpg"',                  html.State.SQ_CSS,
       ')\'',                             html.State.TAG_BODY,
       '>',                               html.State.PCDATA,
       '<textarea cols=50 name=example>', html.State.RCDATA,
       '</input ',                        html.State.RCDATA,
       '></texterror>',                   html.State.RCDATA,
       '</textarea>',                     html.State.PCDATA,
       '<style type=text/css>',           html.State.CDATA_CSS,
       'foo { background: \'',            html.State.CDATA_CSS_SQ,
       'sprinkles.jpg\'',                 html.State.CDATA_CSS,
       ' }</style>',                      html.State.PCDATA,
       '<b>',                             html.State.PCDATA,
       'Baz',                             html.State.PCDATA]);
}

function testAttributeEscaping() {
  var bar = "<b'Ar &>";
  assertEquals(
      ('<a foo="&lt;b&#39;Ar &amp;&gt;" foo="&lt;b&#39;Ar &amp;&gt;"'
       + ' foo=\'&lt;b&#39;Ar &amp;&gt;\' foo=a&lt;b&#39;Ar&#32;&amp;&gt;>'),
      safeHtml(open(Template("<a foo=$bar foo=\"$bar\" foo='$bar' foo=a$bar>")))
      );
}

function testTextNodeEscaping() {
  var bar = "<b'Ar &>";
  assertEquals(
      ('<div>&lt;b&#39;Ar &amp;&gt;</div>'
       + '<textarea>&lt;b&#39;Ar &amp;&gt;</textarea>'
       + '<xmp><b\'Ar &></xmp>'),
      safeHtml(open(Template(
          "<div>$bar</div>"
          + "<textarea>$bar</textarea>"
          + "<xmp>$bar</xmp>"))));
}

function testJavascriptAttribSq() {
  var bar = "<b'Ar &>";
  var n = 400;
  assertEquals(
      '<a onclick=\'alert(\"\\074b\\047Ar &amp;&gt;\" + 401)\'>',
      safeHtml(open(Template("<a onclick='alert($bar + ${n+1})'>"))));
  assertEquals(
      '<a onclick=\'alert(\"\\074b\\047Ar &amp;&gt;\" + 401)\'>',
      safeHtml(open(Template("<a onclick='alert(\"$bar\" + ${n+1})'>"))));
}

function testJavascriptAttribDq() {
  var bar = "<b'Ar &>";
  var n = 400;
  assertEquals(
      '<a onclick="alert(\'\\074b\\047Ar &amp;&gt;\' + false)">',
      safeHtml(open(Template("<a onclick=\"alert($bar + ${n == 401})\">"))));
  assertEquals(
      '<a onclick="alert(\'\\074b\\047Ar &amp;&gt;\' + false)">',
      safeHtml(open(Template("<a onclick=\"alert('$bar' + ${n == 401})\">"))));
}

function testJavascriptAttribSp() {
  var bar = "<b'Ar &>";
  var n = null;
  assertEquals(
      '<a onclick=alert(&#39;\\074b\\047Ar&#32;&amp;&gt;&#39;+null) >',
      safeHtml(open(Template("<a onclick=alert($bar+${n}) >"))));
  assertEquals(
      '<a onclick=alert(\'\\074b\\047Ar&#32;&amp;&gt;\'+null)>',
      safeHtml(open(Template("<a onclick=alert('$bar'+${n})>"))));
}

function testScriptTag() {
  var bar = "<b'Ar &\n>";
  var n = 123;
  var nil = null;
  var mimeType = "javascript";

  assertEquals(
      ('<script type=text/javascript>\n'
       + 's = \'\\074b\\047Ar &\\n>\' + \'\\074b\\047Ar &\\n>\''
       + ' + \"bar\\074b\\047Ar &\\n>";\n'
       + 'var number = 123 * 122;\n'
       + 'null || undefined;\n'
       + '//<\/script>'),
      safeHtml(open(Template(
          "<script type=text/$mimeType>\n"
          + "s = $bar + '$bar' + \"bar$bar\";\n"
          + "var number = $n * ${n - 1};\n"
          + "$nil || undefined;\n"
          + "//<\/script>"))));
}

</script>
<style type=text/css>
.info, .detail { color: black; }
.good { color: #0f0; }
.error { color: #f00; font-weight: bold }
.detail { white-space: pre; margin-left: 2em }
#log li { font-family: monospace }
</style>

</head>
<body bgcolor=white>
<ul id=result></ul>

<ol id=log></ol>

<script type=text/javascript>
if (!Date.now) {
  Date.now = function () { return (new Date).getTime(); };
}
(function () {
  function emit(msg, style, container) {
    var node = document.createElement('LI');
    style && (node.className = style);
    node.appendChild(document.createTextNode(msg));
    container.appendChild(node);
  }
  function emitLogMessage(msg, style) {
    emit(msg, style, document.getElementById('log'));
  }
  function emitResult(msg, style) {
    emit(msg, style, document.getElementById('result'));
  }
  function exceptionToString(ex) {
    return String(ex);
  }
  function traceToString(stack) {
    return stack
        .replace(/@\w+:\/\/.*\/([^\/:]*:\d+)$/mg, '@$1')  // Reduce path length
        .replace(/^(.*)@([^@\r\n]*)$/mg, '$2  @$1');  // Move paths to beginning
  }
  function getParam(name) {
    var query = (document.location.search || '').replace(/^\?/, '');
    if (!query) { return null; }
    var pairs = query.split(/&/g);
    for (var i = pairs.length; --i >= 0;) {
      var m = pairs[i].match(/^([^=]*)(?:=([\s\S]*))?$/);
      if (!m) { continue; }
      var key = decodeURIComponent(m[1]);
      if (key === name) { return decodeURIComponent(m[2] || ''); }
    }
    return null;
  }

  var testFilter = getParam('filter');
  if (testFilter !== null) {
    testFilter = new RegExp(testFilter);
  }

  var testNames = [];
  for (var k in this) {
    if (/^test/.test(k) && 'function' === typeof this[k]) {
      if (!testFilter || testFilter.test(k)) {
        testNames.push(k);
      }
    }
  }
  testNames.sort();

  var nTests = testNames.length;
  var nPassed = 0;
  for (var i = 0; i < nTests; ++i) {
    var testName = testNames[i];
    emitLogMessage(testName + ' starting', 'info');
    var t0 = Date.now();
    try {
      (this[testName])();
    } catch (ex) {
      emitLogMessage(
          testName + ' failed with ' + exceptionToString(ex), 'error');
      if (ex && 'stack' in ex) {
        emitLogMessage(traceToString(ex.stack), 'detail');
      }
      continue;
    }

    var t1 = Date.now();
    emitLogMessage(testName + ' passed in ' + (t1 - t0) + ' ms', 'good');
    ++nPassed;
  }
  emitResult(
      nPassed + '/' + nTests + ' passed',
      nTests === nPassed && nTests ? 'good' : 'error');
})();
</script>
</body>
</html>
